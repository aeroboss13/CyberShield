export interface ExploitInfo {
  id: string;
  title: string;
  description: string;
  cveId?: string;
  exploitType: string;
  platform: string;
  verified: boolean;
  datePublished: string;
  author: string;
  sourceUrl?: string;
  exploitCode?: string;
}

export class ExploitService {
  private static instance: ExploitService;
  private cache: Map<string, ExploitInfo[]> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 4 * 60 * 60 * 1000; // 4 hours
  private updateTimer: NodeJS.Timeout | null = null;

  static getInstance(): ExploitService {
    if (!ExploitService.instance) {
      ExploitService.instance = new ExploitService();
      ExploitService.instance.startBackgroundUpdates();
    }
    return ExploitService.instance;
  }

  private startBackgroundUpdates(): void {
    // Periodically refresh exploit data for high-risk CVEs
    this.updateTimer = setInterval(async () => {
      try {
        await this.refreshHighPriorityCVEs();
      } catch (error) {
        console.error('Error during exploit database update:', error);
      }
    }, 6 * 60 * 60 * 1000); // Every 6 hours

    console.log('Exploit database background updates started');
  }

  private async refreshHighPriorityCVEs(): Promise<void> {
    // Get list of high-priority CVEs from the last 7 days
    const recentCVEs = Array.from(this.cache.keys())
      .map(key => key.replace('exploits_', ''))
      .filter(cveId => {
        const year = parseInt(cveId.match(/CVE-(\d{4})/)?.[1] || '0');
        return year >= new Date().getFullYear() - 1; // Last 2 years
      })
      .slice(0, 20); // Limit to 20 most recent

    console.log(`Refreshing exploit data for ${recentCVEs.length} high-priority CVEs`);
    
    for (const cveId of recentCVEs) {
      try {
        // Clear cache and refetch
        this.cache.delete(`exploits_${cveId}`);
        await this.getExploitsForCVE(cveId);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Rate limiting
      } catch (error) {
        console.error(`Error refreshing exploits for ${cveId}:`, error);
      }
    }
  }

  public stopBackgroundUpdates(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      console.log('Exploit database background updates stopped');
    }
  }

  async getExploitsForCVE(cveId: string, edbId?: string): Promise<ExploitInfo[]> {
    // First check database for real exploits
    try {
      const { storage } = await import('../storage');
      const dbExploits = await storage.getExploitsForCVE(cveId);
      
      if (dbExploits && dbExploits.length > 0) {
        console.log(`Found ${dbExploits.length} exploits in database for ${cveId}`);
        return dbExploits.map(exploit => ({
          id: exploit.id.toString(),
          title: exploit.title,
          description: exploit.description || 'No description available',
          cveId: exploit.cveId,
          exploitType: exploit.exploitType || 'Unknown',
          platform: exploit.platform || 'Unknown',
          verified: exploit.verified,
          datePublished: exploit.datePublished,
          author: exploit.author || 'Unknown',
          sourceUrl: exploit.sourceUrl || undefined,
          exploitCode: exploit.exploitCode || undefined
        }));
      }
    } catch (error) {
      console.error(`Error fetching exploits from database for ${cveId}:`, error);
    }

    // Fall back to external search
    const cacheKey = `exploits_${cveId}_${edbId || 'no-edb'}`;
    const now = Date.now();
    
    if (this.cache.has(cacheKey) && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get(cacheKey) || [];
    }

    try {
      console.log(`Searching exploits for CVE: ${cveId}${edbId ? ` (EDB-ID: ${edbId})` : ''}`);
      
      let exploits: ExploitInfo[] = [];
      
      // Priority 1: If we have EDB-ID, fetch directly from ExploitDB
      if (edbId) {
        console.log(`Direct EDB-ID fetch for ${edbId}`);
        const directExploit = await this.fetchDirectEDBExploit(cveId, edbId);
        if (directExploit) {
          exploits.push(directExploit);
          console.log(`Successfully fetched exploit via EDB-ID: ${edbId}`);
        } else {
          console.warn(`Failed to fetch exploit for EDB-ID: ${edbId}`);
        }
      }
      
      // Priority 2: Fallback to regular search if no EDB-ID or direct fetch failed
      if (exploits.length === 0) {
        exploits = await this.searchExploitSources(cveId);
      }
      
      console.log(`Found ${exploits.length} exploits for ${cveId}`);
      
      this.cache.set(cacheKey, exploits);
      this.lastUpdate = now;
      
      return exploits;
    } catch (error) {
      console.error(`Error fetching exploits for ${cveId}:`, error);
      // Return error status - no synthetic exploits
      return [{
        id: `error-${this.hashString(cveId)}`,
        title: `${cveId} - Search Unavailable`,
        description: `Exploit search is currently unavailable due to network issues. Please try again later or check ExploitDB manually.`,
        cveId,
        exploitType: 'error',
        platform: 'multiple',
        verified: false,
        datePublished: new Date().toISOString().split('T')[0],
        author: 'SecHub Status',
        sourceUrl: `https://www.exploit-db.com/search?cve=${cveId}`,
        exploitCode: `# ${cveId} - Search Temporarily Unavailable
#
# Exploit search encountered a technical error.
# This is likely a temporary network or service issue.
#
# Recommended actions:
# 1. Refresh the page and try again
# 2. Manual search: https://www.exploit-db.com/search?cve=${cveId}
# 3. Check NVD: https://nvd.nist.gov/vuln/detail/${cveId}
#
# Error occurred during search - no synthetic data provided.`
      }];
    }
  }

  private async searchExploitSources(cveId: string): Promise<ExploitInfo[]> {
    const exploits: ExploitInfo[] = [];

    console.log(`Starting comprehensive exploit search for ${cveId}`);

    // Search various exploit databases with priority order
    const results = await Promise.allSettled([
      this.searchExploitDB(cveId),        // Priority 1: ExploitDB (most reliable)
      this.searchGitHubExploits(cveId),   // Priority 2: GitHub PoCs 
      this.searchVulnersExploits(cveId)   // Priority 3: Vulners database
    ]);

    results.forEach((result, index) => {
      const sourceNames = ['ExploitDB', 'GitHub', 'Vulners'];
      if (result.status === 'fulfilled' && result.value && result.value.length > 0) {
        console.log(`${sourceNames[index]} found ${result.value.length} exploits for ${cveId}`);
        exploits.push(...result.value);
      } else if (result.status === 'rejected') {
        console.warn(`${sourceNames[index]} search failed for ${cveId}:`, result.reason);
      } else {
        console.log(`${sourceNames[index]} found no exploits for ${cveId}`);
      }
    });

    // Remove duplicates and sort by verification status
    const uniqueExploits = this.deduplicateExploits(exploits);
    return uniqueExploits.sort((a, b) => {
      if (a.verified && !b.verified) return -1;
      if (!a.verified && b.verified) return 1;
      return new Date(b.datePublished).getTime() - new Date(a.datePublished).getTime();
    });
  }

  private async searchExploitDB(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Use a more realistic approach to search for exploits
      // Search Google for ExploitDB results related to the CVE
      const exploits: ExploitInfo[] = [];
      
      // Method 1: Direct ExploitDB CVE search (most accurate)
      await this.searchExploitDBDirect(cveId, exploits);
      
      // Method 2: Fallback to RSS feed search if direct search didn't find much
      if (exploits.length < 2) {
        await this.searchExploitDBRSS(cveId, exploits);
      }

      // If no specific exploits found in ExploitDB, be more transparent
      if (exploits.length === 0) {
        console.log(`No exploits found in ExploitDB for ${cveId}, providing research guidance`);
        
        const year = cveId.match(/CVE-(\d{4})/)?.[1];
        
        // For recent CVEs (2024+), they might not have exploits yet
        if (year && parseInt(year) >= 2024) {
          console.log(`Very recent CVE (${year}), limited exploit availability expected`);
          exploits.push({
            id: `edb-recent-${this.hashString(cveId)}`,
            title: `${cveId} - Recent Vulnerability (No Public Exploits)`,
            description: `This is a recent ${year} vulnerability. Public exploits may not be available yet. Monitor ExploitDB and security advisories for updates.`,
            cveId,
            exploitType: 'monitoring',
            platform: 'multiple', 
            verified: false,
            datePublished: `${year}-01-01`,
            author: 'SecHub Analysis',
            sourceUrl: `https://www.exploit-db.com/search?cve=${cveId}`,
            exploitCode: `# ${cveId} - Recent Vulnerability Analysis
# Status: No public exploits found in ExploitDB
# 
# This vulnerability was published in ${year}
# Public exploits may not be available due to:
# - Recent discovery
# - Complex exploitation requirements  
# - Effective vendor mitigations
#
# Recommended Actions:
# 1. Apply vendor security patches
# 2. Monitor ExploitDB: ${`https://www.exploit-db.com/search?cve=${cveId}`}
# 3. Check NVD details: https://nvd.nist.gov/vuln/detail/${cveId}
# 4. Implement defense-in-depth controls`
          });
        } else if (year && parseInt(year) >= 2020) {
          exploits.push({
            id: `edb-notfound-${this.hashString(cveId)}`,
            title: `${cveId} - No Public Exploits Found`,  
            description: `No public exploits found in ExploitDB for ${cveId}. This may indicate limited research or complex exploitation requirements.`,
            cveId,
            exploitType: 'research',
            platform: 'multiple',
            verified: false,
            datePublished: `${year}-01-01`,
            author: 'SecHub Analysis',
            sourceUrl: `https://www.exploit-db.com/search?cve=${cveId}`,
            exploitCode: `# ${cveId} - Research Required
# Status: No public exploits found in ExploitDB
#
# Manual research recommended:
# 1. ExploitDB search: ${`https://www.exploit-db.com/search?cve=${cveId}`}
# 2. Security advisories and patches
# 3. Research papers and disclosures
# 4. GitHub proof-of-concept code
#
# Limited public exploits may indicate:
# - Complex vulnerability requiring specialized knowledge
# - Effective vendor response and patching
# - Limited attacker interest or capability`
          });
        }
      }

      return exploits;
    } catch (error) {
      console.error('Error searching ExploitDB:', error);
      return [];
    }
  }

  private async searchExploitDBDirect(cveId: string, exploits: ExploitInfo[]): Promise<void> {
    try {
      console.log(`Direct ExploitDB search for ${cveId}`);
      
      // Search ExploitDB using their search functionality
      const searchUrl = `https://www.exploit-db.com/search?cve=${encodeURIComponent(cveId)}`;
      
      const response = await fetch(searchUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; SecHub/1.0; CVE Research Bot)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        }
      });
      
      if (response.ok) {
        const html = await response.text();
        
        // Look for exploit table rows
        const tableRowMatches = html.match(/<tr[^>]*data-code-id=\"\d+\"[^>]*>[\s\S]*?<\/tr>/g);
        
        if (tableRowMatches && tableRowMatches.length > 0) {
          console.log(`Found ${tableRowMatches.length} ExploitDB matches for ${cveId}`);
          
          for (const row of tableRowMatches.slice(0, 3)) { // Limit to 3 results
            const exploitIdMatch = row.match(/data-code-id=\"(\d+)\"/);  
            const titleMatch = row.match(/<a[^>]*href=\"\/exploits\/\d+\"[^>]*>([^<]+)<\/a>/);
            const dateMatch = row.match(/<td[^>]*>(\d{4}-\d{2}-\d{2})<\/td>/);
            const authorMatch = row.match(/<td[^>]*title=\"[^\"]*\">([^<]+)<\/td>/);
            
            if (exploitIdMatch && titleMatch) {
              const exploitId = exploitIdMatch[1];
              const title = titleMatch[1].trim();
              const datePublished = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];
              const author = authorMatch ? authorMatch[1].trim() : 'ExploitDB Contributor';
              
              // Fetch the actual exploit code
              const exploitCode = await this.fetchExploitCode(exploitId);
              
              exploits.push({
                id: `edb-direct-${exploitId}`,
                title: `${title} (ExploitDB)`,
                description: `Real exploit code for ${cveId} from ExploitDB database. This exploit has been verified and published by the security research community.`,
                cveId,
                exploitType: this.detectExploitType(title),
                platform: this.detectPlatform(title),
                verified: true,
                datePublished,
                author,
                sourceUrl: `https://www.exploit-db.com/exploits/${exploitId}`,
                exploitCode
              });
            }
          }
        } else {
          console.log(`No table matches found for ${cveId} in ExploitDB`);
        }
      } else {
        console.warn(`ExploitDB search failed for ${cveId}: ${response.status}`);
      }
      
    } catch (error) {
      console.error(`Error in direct ExploitDB search for ${cveId}:`, error);
    }
  }
  
  private async searchExploitDBRSS(cveId: string, exploits: ExploitInfo[]): Promise<void> {
    try {
      console.log(`RSS ExploitDB search for ${cveId}`);
      
      // Try to fetch from ExploitDB's RSS feed and filter by CVE
      const rssResponse = await fetch('https://www.exploit-db.com/rss.xml', {
        headers: {
          'User-Agent': 'SecHub/1.0 RSS Reader'
        }
      });
      
      if (rssResponse.ok) {
        const rssText = await rssResponse.text();
        
        // Simple XML parsing to extract exploit info
        const matches = rssText.match(/<item>[\s\S]*?<\/item>/g);
        
        if (matches) {
          const exploitPromises = matches.map(async (item, index) => {
            const titleMatch = item.match(/<title><!\[CDATA\[(.*?)\]\]><\/title>/);
            const linkMatch = item.match(/<link>(.*?)<\/link>/);
            const descMatch = item.match(/<description><!\[CDATA\[(.*?)\]\]><\/description>/);
            const pubDateMatch = item.match(/<pubDate>(.*?)<\/pubDate>/);
            
            const title = titleMatch?.[1] || '';
            const link = linkMatch?.[1] || '';
            const description = descMatch?.[1] || '';
            const pubDate = pubDateMatch?.[1] || '';
            
            // Check if this exploit is related to our CVE
            if (title.toLowerCase().includes(cveId.toLowerCase()) || 
                description.toLowerCase().includes(cveId.toLowerCase())) {
              
              const exploitId = link.match(/\/exploits\/(\d+)/)?.[1] || index.toString();
              const exploitCode = await this.fetchExploitCode(exploitId);
              
              return {
                id: `edb-rss-${exploitId}`,
                title: title.replace(/^.*? - /, ''), // Clean up title
                description: this.stripHtml(description) || `Exploit for ${cveId} from ExploitDB RSS`,
                cveId,
                exploitType: this.detectExploitType(title),
                platform: this.detectPlatform(title),
                verified: true,
                datePublished: new Date(pubDate).toISOString().split('T')[0],
                author: 'ExploitDB Contributor',
                sourceUrl: link,
                exploitCode
              };
            }
            return null;
          });

          const results = await Promise.all(exploitPromises);
          const rssExploits = results.filter(result => result !== null) as ExploitInfo[];
          
          // Add only new exploits (not duplicates)
          rssExploits.forEach(exploit => {
            if (!exploits.some(existing => existing.sourceUrl === exploit.sourceUrl)) {
              exploits.push(exploit);
            }
          });
        }
      }
    } catch (error) {
      console.error(`Error in RSS ExploitDB search for ${cveId}:`, error);
    }
  }
  
  private async fetchExploitCode(exploitId: string): Promise<string | undefined> {
    try {
      console.log(`Fetching raw exploit code for EDB-ID: ${exploitId}`);
      
      // Try to fetch the raw exploit code from ExploitDB
      const response = await fetch(`https://www.exploit-db.com/raw/${exploitId}`, {
        headers: {
          'User-Agent': 'SecHub/1.0 Exploit Fetcher',
          'Accept': 'text/plain,*/*'
        }
      });
      
      if (response.ok) {
        const code = await response.text();
        
        // Clean up and validate the code
        if (code && code.trim().length > 10) {
          // Limit code size for display
          const cleanCode = code.trim();
          if (cleanCode.length > 15000) {
            return cleanCode.substring(0, 15000) + '\n\n... [Code truncated - view full exploit at source URL]';
          }
          return cleanCode;
        }
      } else {
        console.warn(`Could not fetch raw code for exploit ${exploitId}: ${response.status}`);
      }
    } catch (error) {
      console.error(`Error fetching exploit code for ${exploitId}:`, error);
    }
    
    return undefined;
  }

  private detectExploitType(title: string): string {
    const lowerTitle = title.toLowerCase();
    
    if (lowerTitle.includes('remote') || lowerTitle.includes('rce')) return 'remote';
    if (lowerTitle.includes('local') || lowerTitle.includes('privilege')) return 'local';
    if (lowerTitle.includes('dos') || lowerTitle.includes('denial')) return 'dos';
    if (lowerTitle.includes('sql') || lowerTitle.includes('injection')) return 'injection';
    if (lowerTitle.includes('xss') || lowerTitle.includes('cross-site')) return 'xss';
    if (lowerTitle.includes('csrf')) return 'csrf';
    if (lowerTitle.includes('buffer') || lowerTitle.includes('overflow')) return 'overflow';
    
    return 'exploit';
  }

  private detectPlatform(title: string): string {
    const lowerTitle = title.toLowerCase();
    
    if (lowerTitle.includes('windows')) return 'windows';
    if (lowerTitle.includes('linux')) return 'linux';
    if (lowerTitle.includes('macos') || lowerTitle.includes('osx')) return 'macos';
    if (lowerTitle.includes('android')) return 'android';
    if (lowerTitle.includes('ios')) return 'ios';
    if (lowerTitle.includes('web') || lowerTitle.includes('php') || lowerTitle.includes('asp')) return 'web';
    
    return 'multiple';
  }

  private stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, ' ').trim();
  }

  private async searchGitHubExploits(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Search GitHub for exploit repositories
      const query = `${cveId} exploit poc`;
      const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&sort=updated&order=desc&per_page=5`;
      
      const response = await fetch(url, {
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecHub/1.0'
        }
      });

      if (!response.ok) {
        console.warn('GitHub API rate limited or error');
        return [];
      }

      const data = await response.json();
      const exploits: ExploitInfo[] = [];

      if (data.items && Array.isArray(data.items)) {
        data.items.forEach((repo: any) => {
          if (repo.name && repo.description) {
            exploits.push({
              id: `gh-${repo.id}`,
              title: `${repo.name} - GitHub Repository`,
              description: repo.description || `GitHub repository containing exploit code for ${cveId}`,
              cveId,
              exploitType: 'repository',
              platform: 'multiple',
              verified: repo.stargazers_count > 5, // Consider repos with >5 stars as more credible
              datePublished: repo.created_at.split('T')[0],
              author: repo.owner?.login || 'Unknown',
              sourceUrl: repo.html_url
            });
          }
        });
      }

      return exploits;
    } catch (error) {
      console.error('Error searching GitHub exploits:', error);
      return [];
    }
  }

  private async searchVulnersExploits(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Vulners.com has an API for exploit data
      const url = `https://vulners.com/api/v3/search/lucene/`;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: `${cveId} AND type:exploit`,
          size: 10
        })
      });

      if (!response.ok) {
        return [];
      }

      const data = await response.json();
      const exploits: ExploitInfo[] = [];

      if (data.data && data.data.search) {
        data.data.search.forEach((item: any) => {
          if (item._source) {
            exploits.push({
              id: `vln-${item._id}`,
              title: item._source.title || `Exploit for ${cveId}`,
              description: item._source.description || `Vulnerability exploit from Vulners database`,
              cveId,
              exploitType: item._source.type || 'exploit',
              platform: item._source.bulletinFamily || 'multiple',
              verified: true,
              datePublished: item._source.published || '2024-01-01',
              author: item._source.sourceData?.author || 'Vulners',
              sourceUrl: `https://vulners.com/${item._source.type}/${item._id}`
            });
          }
        });
      }

      return exploits;
    } catch (error) {
      console.error('Error searching Vulners exploits:', error);
      return [];
    }
  }

  private deduplicateExploits(exploits: ExploitInfo[]): ExploitInfo[] {
    const seen = new Set<string>();
    return exploits.filter(exploit => {
      const key = `${exploit.title}-${exploit.author}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  // REMOVED: generateSampleExploitCode() - synthetic exploit generation removed per user requirement

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }

  private async fetchDirectEDBExploit(cveId: string, edbId: string): Promise<ExploitInfo | null> {
    try {
      console.log(`Fetching direct exploit from EDB-ID: ${edbId}`);
      
      // Fetch the exploit page to get metadata
      const pageResponse = await fetch(`https://www.exploit-db.com/exploits/${edbId}`, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; SecHub/1.0; CVE Research Bot)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        }
      });
      
      if (!pageResponse.ok) {
        console.warn(`Failed to fetch EDB page for ${edbId}: ${pageResponse.status}`);
        return null;
      }
      
      const pageHtml = await pageResponse.text();
      
      // Extract metadata from the page
      const titleMatch = pageHtml.match(/<title>([^<]+)<\/title>/i);
      const authorMatch = pageHtml.match(/Author:[\\s]*<[^>]*>([^<]+)</i);
      const dateMatch = pageHtml.match(/Date:[\\s]*<[^>]*>([^<]+)</i);
      const platformMatch = pageHtml.match(/Platform:[\\s]*<[^>]*>([^<]+)</i);
      
      const title = titleMatch ? titleMatch[1].replace(' - Exploit Database', '').trim() : `${cveId} Exploit`;
      const author = authorMatch ? authorMatch[1].trim() : 'ExploitDB Contributor';
      const datePublished = dateMatch ? 
        new Date(dateMatch[1].trim()).toISOString().split('T')[0] : 
        new Date().toISOString().split('T')[0];
      const platform = platformMatch ? platformMatch[1].trim().toLowerCase() : 'multiple';
      
      // Fetch the raw exploit code
      const rawResponse = await fetch(`https://www.exploit-db.com/raw/${edbId}`, {
        headers: {
          'User-Agent': 'SecHub/1.0 Direct EDB Fetcher',
          'Accept': 'text/plain,*/*'
        }
      });
      
      if (!rawResponse.ok) {
        console.warn(`Failed to fetch raw exploit for EDB-ID ${edbId}: ${rawResponse.status}`);
        return null;
      }
      
      const exploitCode = await rawResponse.text();
      
      if (!exploitCode || exploitCode.trim().length < 10) {
        console.warn(`Empty or invalid exploit code for EDB-ID ${edbId}`);
        return null;
      }
      
      return {
        id: `edb-direct-${edbId}`,
        title: `${title} (EDB-${edbId})`,
        description: `Real exploit code for ${cveId} directly from ExploitDB. This exploit has been verified and published by security researchers.`,
        cveId,
        exploitType: this.detectExploitType(title),
        platform: this.detectPlatform(platform),
        verified: true,
        datePublished,
        author,
        sourceUrl: `https://www.exploit-db.com/exploits/${edbId}`,
        exploitCode: exploitCode.trim()
      };
      
    } catch (error) {
      console.error(`Error fetching direct EDB exploit ${edbId}:`, error);
      return null;
    }
  }
  
  // REMOVED: Synthetic exploit generation functions - all removed per user requirement

  // REMOVED: generateBufferOverflowCode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generateSQLInjectionCode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generateXSSCode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generateRCECode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generatePrivEscCode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generateDirectoryTraversalCode() - synthetic exploit generation removed per user requirement
  
  // REMOVED: generateCSRFCode() - synthetic exploit generation removed per user requirement
  
  private generateAnalysisTemplate(cveId: string): string {
    return `# ${cveId} Security Analysis

## Vulnerability Overview
This document provides analysis guidelines for ${cveId}.

## Research Steps
1. Review the CVE description in NVD database
2. Check vendor security advisories
3. Search for proof-of-concept code in:
   - ExploitDB (https://www.exploit-db.com/search?cve=${cveId})
   - GitHub repositories
   - Security research papers

## Analysis Checklist
- [ ] Identify affected software versions
- [ ] Determine attack vector (remote/local)
- [ ] Assess impact (confidentiality, integrity, availability)
- [ ] Check for existing patches or workarounds
- [ ] Test in controlled environment

## Exploitation Considerations
- Attack complexity
- Required privileges
- User interaction needed
- Network accessibility

## Mitigation Strategies
- Apply vendor patches
- Implement workarounds if patches unavailable
- Network segmentation
- Access controls

## References
- NVD: https://nvd.nist.gov/vuln/detail/${cveId}
- MITRE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId}
- ExploitDB: https://www.exploit-db.com/search?cve=${cveId}`;
  }

  async searchExploits(query: string): Promise<ExploitInfo[]> {
    // Search across all cached exploits
    const allExploits: ExploitInfo[] = [];
    
    for (const exploits of Array.from(this.cache.values())) {
      allExploits.push(...exploits);
    }

    return allExploits.filter(exploit => 
      exploit.title.toLowerCase().includes(query.toLowerCase()) ||
      exploit.description.toLowerCase().includes(query.toLowerCase()) ||
      exploit.cveId?.toLowerCase().includes(query.toLowerCase()) ||
      exploit.exploitType.toLowerCase().includes(query.toLowerCase())
    );
  }
}