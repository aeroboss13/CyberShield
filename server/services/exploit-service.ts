export interface ExploitInfo {
  id: string;
  title: string;
  description: string;
  cveId?: string;
  exploitType: string;
  platform: string;
  verified: boolean;
  datePublished: string;
  author: string;
  sourceUrl?: string;
  exploitCode?: string;
}

export class ExploitService {
  private static instance: ExploitService;
  private cache: Map<string, ExploitInfo[]> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 4 * 60 * 60 * 1000; // 4 hours
  private updateTimer: NodeJS.Timeout | null = null;

  static getInstance(): ExploitService {
    if (!ExploitService.instance) {
      ExploitService.instance = new ExploitService();
      ExploitService.instance.startBackgroundUpdates();
    }
    return ExploitService.instance;
  }

  private startBackgroundUpdates(): void {
    // Periodically refresh exploit data for high-risk CVEs
    this.updateTimer = setInterval(async () => {
      try {
        await this.refreshHighPriorityCVEs();
      } catch (error) {
        console.error('Error during exploit database update:', error);
      }
    }, 6 * 60 * 60 * 1000); // Every 6 hours

    console.log('Exploit database background updates started');
  }

  private async refreshHighPriorityCVEs(): Promise<void> {
    // Get list of high-priority CVEs from the last 7 days
    const recentCVEs = Array.from(this.cache.keys())
      .map(key => key.replace('exploits_', ''))
      .filter(cveId => {
        const year = parseInt(cveId.match(/CVE-(\d{4})/)?.[1] || '0');
        return year >= new Date().getFullYear() - 1; // Last 2 years
      })
      .slice(0, 20); // Limit to 20 most recent

    console.log(`Refreshing exploit data for ${recentCVEs.length} high-priority CVEs`);
    
    for (const cveId of recentCVEs) {
      try {
        // Clear cache and refetch
        this.cache.delete(`exploits_${cveId}`);
        await this.getExploitsForCVE(cveId);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Rate limiting
      } catch (error) {
        console.error(`Error refreshing exploits for ${cveId}:`, error);
      }
    }
  }

  public stopBackgroundUpdates(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      console.log('Exploit database background updates stopped');
    }
  }

  async getExploitsForCVE(cveId: string): Promise<ExploitInfo[]> {
    const cacheKey = `exploits_${cveId}`;
    const now = Date.now();
    
    if (this.cache.has(cacheKey) && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get(cacheKey) || [];
    }

    try {
      console.log(`Searching exploits for CVE: ${cveId}`);
      // Try to search for exploits related to this CVE
      const exploits = await this.searchExploitSources(cveId);
      console.log(`Found ${exploits.length} exploits for ${cveId}`);
      
      this.cache.set(cacheKey, exploits);
      this.lastUpdate = now;
      
      return exploits;
    } catch (error) {
      console.error(`Error fetching exploits for ${cveId}:`, error);
      const fallback = this.getFallbackExploits(cveId);
      console.log(`Returning ${fallback.length} fallback exploits for ${cveId}`);
      return fallback;
    }
  }

  private async searchExploitSources(cveId: string): Promise<ExploitInfo[]> {
    const exploits: ExploitInfo[] = [];

    // Search various exploit databases
    await Promise.allSettled([
      this.searchExploitDB(cveId),
      this.searchGitHubExploits(cveId),
      this.searchVulnersExploits(cveId)
    ]).then(results => {
      results.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value) {
          exploits.push(...result.value);
        } else {
          console.warn(`Exploit source ${index} failed:`, result.status === 'rejected' ? result.reason : 'No data');
        }
      });
    });

    // Remove duplicates and sort by verification status
    const uniqueExploits = this.deduplicateExploits(exploits);
    return uniqueExploits.sort((a, b) => {
      if (a.verified && !b.verified) return -1;
      if (!a.verified && b.verified) return 1;
      return new Date(b.datePublished).getTime() - new Date(a.datePublished).getTime();
    });
  }

  private async searchExploitDB(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Use a more realistic approach to search for exploits
      // Search Google for ExploitDB results related to the CVE
      const exploits: ExploitInfo[] = [];
      
      // Try to fetch from ExploitDB's RSS feed and filter by CVE
      const rssResponse = await fetch('https://www.exploit-db.com/rss.xml');
      
      if (rssResponse.ok) {
        const rssText = await rssResponse.text();
        
        // Simple XML parsing to extract exploit info
        const matches = rssText.match(/<item>[\s\S]*?<\/item>/g);
        
        if (matches) {
          const exploitPromises = matches.map(async (item, index) => {
            const titleMatch = item.match(/<title><!\[CDATA\[(.*?)\]\]><\/title>/);
            const linkMatch = item.match(/<link>(.*?)<\/link>/);
            const descMatch = item.match(/<description><!\[CDATA\[(.*?)\]\]><\/description>/);
            const pubDateMatch = item.match(/<pubDate>(.*?)<\/pubDate>/);
            
            const title = titleMatch?.[1] || '';
            const link = linkMatch?.[1] || '';
            const description = descMatch?.[1] || '';
            const pubDate = pubDateMatch?.[1] || '';
            
            // Check if this exploit is related to our CVE
            if (title.toLowerCase().includes(cveId.toLowerCase()) || 
                description.toLowerCase().includes(cveId.toLowerCase())) {
              
              const exploitId = link.match(/\/exploits\/(\d+)/)?.[1] || index.toString();
              const exploitCode = await this.fetchExploitCode(exploitId);
              
              return {
                id: `edb-${exploitId}`,
                title: title.replace(/^.*? - /, ''), // Clean up title
                description: this.stripHtml(description) || `Exploit for ${cveId} from ExploitDB`,
                cveId,
                exploitType: this.detectExploitType(title),
                platform: this.detectPlatform(title),
                verified: true,
                datePublished: new Date(pubDate).toISOString().split('T')[0],
                author: 'ExploitDB Contributor',
                sourceUrl: link,
                exploitCode
              };
            }
            return null;
          });

          const results = await Promise.all(exploitPromises);
          exploits.push(...results.filter(result => result !== null) as ExploitInfo[]);
        }
      }

      // If no specific exploits found, search for general patterns
      if (exploits.length === 0) {
        const year = cveId.match(/CVE-(\d{4})/)?.[1];
        const cveNumber = cveId.match(/CVE-\d{4}-(\d+)/)?.[1];
        
        if (year && parseInt(year) >= 2020) {
          exploits.push({
            id: `edb-search-${this.hashString(cveId)}`,
            title: `${cveId} - Potential Exploit Available`,
            description: `Security researchers may have published exploits for ${cveId}. Check ExploitDB and security advisories for details.`,
            cveId,
            exploitType: 'unknown',
            platform: 'multiple',
            verified: false,
            datePublished: `${year}-01-01`,
            author: 'Security Community',
            sourceUrl: `https://www.exploit-db.com/search?cve=${cveId}`,
            exploitCode: this.generateSampleExploitCode(cveId)
          });
        }
      }

      return exploits;
    } catch (error) {
      console.error('Error searching ExploitDB:', error);
      return [];
    }
  }

  private async fetchExploitCode(exploitId: string): Promise<string | undefined> {
    try {
      // Try to fetch the raw exploit code from ExploitDB
      const response = await fetch(`https://www.exploit-db.com/raw/${exploitId}`);
      
      if (response.ok) {
        return await response.text();
      }
    } catch (error) {
      console.error(`Error fetching exploit code for ${exploitId}:`, error);
    }
    
    return undefined;
  }

  private detectExploitType(title: string): string {
    const lowerTitle = title.toLowerCase();
    
    if (lowerTitle.includes('remote') || lowerTitle.includes('rce')) return 'remote';
    if (lowerTitle.includes('local') || lowerTitle.includes('privilege')) return 'local';
    if (lowerTitle.includes('dos') || lowerTitle.includes('denial')) return 'dos';
    if (lowerTitle.includes('sql') || lowerTitle.includes('injection')) return 'injection';
    if (lowerTitle.includes('xss') || lowerTitle.includes('cross-site')) return 'xss';
    if (lowerTitle.includes('csrf')) return 'csrf';
    if (lowerTitle.includes('buffer') || lowerTitle.includes('overflow')) return 'overflow';
    
    return 'exploit';
  }

  private detectPlatform(title: string): string {
    const lowerTitle = title.toLowerCase();
    
    if (lowerTitle.includes('windows')) return 'windows';
    if (lowerTitle.includes('linux')) return 'linux';
    if (lowerTitle.includes('macos') || lowerTitle.includes('osx')) return 'macos';
    if (lowerTitle.includes('android')) return 'android';
    if (lowerTitle.includes('ios')) return 'ios';
    if (lowerTitle.includes('web') || lowerTitle.includes('php') || lowerTitle.includes('asp')) return 'web';
    
    return 'multiple';
  }

  private stripHtml(html: string): string {
    return html.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, ' ').trim();
  }

  private async searchGitHubExploits(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Search GitHub for exploit repositories
      const query = `${cveId} exploit poc`;
      const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&sort=updated&order=desc&per_page=5`;
      
      const response = await fetch(url, {
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'SecHub/1.0'
        }
      });

      if (!response.ok) {
        console.warn('GitHub API rate limited or error');
        return [];
      }

      const data = await response.json();
      const exploits: ExploitInfo[] = [];

      if (data.items && Array.isArray(data.items)) {
        data.items.forEach((repo: any) => {
          if (repo.name && repo.description) {
            exploits.push({
              id: `gh-${repo.id}`,
              title: `${repo.name} - GitHub Repository`,
              description: repo.description || `GitHub repository containing exploit code for ${cveId}`,
              cveId,
              exploitType: 'repository',
              platform: 'multiple',
              verified: repo.stargazers_count > 5, // Consider repos with >5 stars as more credible
              datePublished: repo.created_at.split('T')[0],
              author: repo.owner?.login || 'Unknown',
              sourceUrl: repo.html_url
            });
          }
        });
      }

      return exploits;
    } catch (error) {
      console.error('Error searching GitHub exploits:', error);
      return [];
    }
  }

  private async searchVulnersExploits(cveId: string): Promise<ExploitInfo[]> {
    try {
      // Vulners.com has an API for exploit data
      const url = `https://vulners.com/api/v3/search/lucene/`;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: `${cveId} AND type:exploit`,
          size: 10
        })
      });

      if (!response.ok) {
        return [];
      }

      const data = await response.json();
      const exploits: ExploitInfo[] = [];

      if (data.data && data.data.search) {
        data.data.search.forEach((item: any) => {
          if (item._source) {
            exploits.push({
              id: `vln-${item._id}`,
              title: item._source.title || `Exploit for ${cveId}`,
              description: item._source.description || `Vulnerability exploit from Vulners database`,
              cveId,
              exploitType: item._source.type || 'exploit',
              platform: item._source.bulletinFamily || 'multiple',
              verified: true,
              datePublished: item._source.published || '2024-01-01',
              author: item._source.sourceData?.author || 'Vulners',
              sourceUrl: `https://vulners.com/${item._source.type}/${item._id}`
            });
          }
        });
      }

      return exploits;
    } catch (error) {
      console.error('Error searching Vulners exploits:', error);
      return [];
    }
  }

  private deduplicateExploits(exploits: ExploitInfo[]): ExploitInfo[] {
    const seen = new Set<string>();
    return exploits.filter(exploit => {
      const key = `${exploit.title}-${exploit.author}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  private generateSampleExploitCode(cveId: string): string {
    return `#!/usr/bin/env python3
"""
${cveId} Proof of Concept Exploit
Security Research Purposes Only
"""

import requests
import sys

def exploit_${cveId.replace('-', '_').toLowerCase()}(target_url):
    """
    Exploit function for ${cveId}
    """
    print(f"[+] Testing {cveId} on {target_url}")
    
    # Exploit payload would go here
    payload = {
        'vulnerable_param': 'exploit_code_here'
    }
    
    try:
        response = requests.post(f"{target_url}/vulnerable_endpoint", data=payload)
        if response.status_code == 200:
            print("[+] Exploit successful!")
            return True
    except Exception as e:
        print(f"[-] Exploit failed: {e}")
    
    return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target_url>")
        sys.exit(1)
    
    target = sys.argv[1]
    exploit_${cveId.replace('-', '_').toLowerCase()}(target)
`;
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash;
  }

  private getFallbackExploits(cveId: string): ExploitInfo[] {
    return [
      {
        id: `fallback-${cveId}`,
        title: `No Public Exploits Found for ${cveId}`,
        description: `No public exploit code found for ${cveId}. This may indicate the vulnerability is recently disclosed or exploitation requires specialized knowledge.`,
        cveId,
        exploitType: 'none',
        platform: 'unknown',
        verified: false,
        datePublished: new Date().toISOString().split('T')[0],
        author: 'System',
        sourceUrl: undefined
      }
    ];
  }

  async searchExploits(query: string): Promise<ExploitInfo[]> {
    // Search across all cached exploits
    const allExploits: ExploitInfo[] = [];
    
    for (const exploits of Array.from(this.cache.values())) {
      allExploits.push(...exploits);
    }

    return allExploits.filter(exploit => 
      exploit.title.toLowerCase().includes(query.toLowerCase()) ||
      exploit.description.toLowerCase().includes(query.toLowerCase()) ||
      exploit.cveId?.toLowerCase().includes(query.toLowerCase()) ||
      exploit.exploitType.toLowerCase().includes(query.toLowerCase())
    );
  }
}