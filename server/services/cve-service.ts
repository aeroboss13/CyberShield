import type { CVE } from "@shared/schema";

interface NVDCVEItem {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        cvssData: {
          baseScore: number;
          baseSeverity: string;
        };
      }>;
    };
    configurations?: Array<{
      nodes: Array<{
        cpeMatch: Array<{
          criteria: string;
          vulnerable: boolean;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
    }>;
  };
}

interface NVDResponse {
  vulnerabilities: NVDCVEItem[];
  totalResults: number;
  resultsPerPage: number;
  startIndex: number;
}

interface CISAKEVItem {
  cveID: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

interface PaginatedCVEResult {
  data: CVE[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

interface CVEQueryParams {
  search?: string;
  severity?: string;
  onlyWithExploits?: boolean;
  yearRange?: string;
  page: number;
  limit: number;
}

export class CVEService {
  private static instance: CVEService;
  private cache: Map<string, any> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 2 * 60 * 60 * 1000; // 2 hours for individual pages
  private readonly NVD_BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
  private readonly CISA_KEV_URL = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';

  static getInstance(): CVEService {
    if (!CVEService.instance) {
      CVEService.instance = new CVEService();
      // Start background CVE data loading
      CVEService.instance.fetchComprehensiveCVEsInBackground().catch(console.error);
    }
    return CVEService.instance;
  }

  private async fetchWithRetry(url: string, options?: RequestInit, retries = 3): Promise<Response> {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            'User-Agent': 'SecHub/1.0',
            ...options?.headers,
          },
        });
        
        if (response.status === 429) {
          // Rate limited, wait and retry
          const waitTime = Math.pow(2, i) * 1000; // Exponential backoff
          console.log(`Rate limited, waiting ${waitTime}ms before retry ${i + 1}/${retries}`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        return response;
      } catch (error) {
        console.error(`Attempt ${i + 1} failed:`, error);
        if (i === retries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
    throw new Error('All retry attempts failed');
  }

  private async fetchCISAKEV(): Promise<Set<string>> {
    try {
      const response = await this.fetchWithRetry(this.CISA_KEV_URL);
      if (!response.ok) {
        console.warn('Failed to fetch CISA KEV data');
        return new Set();
      }

      const data = await response.json();
      const kevCVEs = new Set<string>();
      
      if (data.vulnerabilities && Array.isArray(data.vulnerabilities)) {
        data.vulnerabilities.forEach((item: CISAKEVItem) => {
          if (item.cveID) {
            kevCVEs.add(item.cveID);
          }
        });
      }

      console.log(`Loaded ${kevCVEs.size} CVEs from CISA KEV`);
      return kevCVEs;
    } catch (error) {
      console.error('Error fetching CISA KEV data:', error);
      return new Set();
    }
  }

  private async fetchNVDData(params: Record<string, string> = {}): Promise<NVDResponse> {
    const url = new URL(this.NVD_BASE_URL);
    
    // Default parameters - increased for efficiency
    const defaultParams = {
      resultsPerPage: '2000', // Maximum allowed by NVD API
      startIndex: '0',
      ...params
    };

    Object.entries(defaultParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });

    console.log('Fetching CVE data from NVD:', url.toString());
    
    const response = await this.fetchWithRetry(url.toString());
    
    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
    }

    const data: NVDResponse = await response.json();
    console.log(`Fetched ${data.vulnerabilities.length} CVEs from NVD`);
    
    return data;
  }

  private transformNVDToCVE(nvdItem: NVDCVEItem, isActivelyExploited: boolean): CVE {
    const cve = nvdItem.cve;
    const description = cve.descriptions.find(d => d.lang === 'en')?.value || '';
    const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseScore?.toString() || null;
    const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN';
    
    // Extract vendor/product from CPE if available
    let vendor = null;
    if (cve.configurations?.[0]?.nodes?.[0]?.cpeMatch?.[0]?.criteria) {
      const cpe = cve.configurations[0].nodes[0].cpeMatch[0].criteria;
      const cpeParts = cpe.split(':');
      if (cpeParts.length > 3) {
        vendor = cpeParts[3];
      }
    }

    // Generate tags based on content
    const tags = this.generateTags(description, severity, isActivelyExploited);

    return {
      id: Math.abs(this.hashString(cve.id)), // Generate numeric ID from string
      cveId: cve.id,
      title: `${cve.id} - ${severity} Vulnerability`,
      description: description.length > 500 ? description.substring(0, 500) + '...' : description,
      cvssScore,
      severity: severity.toUpperCase(),
      vendor,
      publishedDate: cve.published.split('T')[0],
      updatedDate: cve.lastModified.split('T')[0],
      tags,
      activelyExploited: isActivelyExploited
    };
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash;
  }

  private generateTags(description: string, severity: string, isActivelyExploited: boolean): string[] {
    const tags: string[] = [];
    const lowerDesc = description.toLowerCase();

    // Add severity tag
    tags.push(severity.toLowerCase());

    // Add exploitation status
    if (isActivelyExploited) {
      tags.push('actively-exploited');
    }

    // Add vulnerability type tags
    if (lowerDesc.includes('remote code execution') || lowerDesc.includes('rce')) {
      tags.push('rce');
    }
    if (lowerDesc.includes('sql injection') || lowerDesc.includes('sqli')) {
      tags.push('sqli');
    }
    if (lowerDesc.includes('cross-site scripting') || lowerDesc.includes('xss')) {
      tags.push('xss');
    }
    if (lowerDesc.includes('privilege escalation')) {
      tags.push('privilege-escalation');
    }
    if (lowerDesc.includes('denial of service') || lowerDesc.includes('dos')) {
      tags.push('dos');
    }
    if (lowerDesc.includes('buffer overflow')) {
      tags.push('buffer-overflow');
    }
    if (lowerDesc.includes('path traversal') || lowerDesc.includes('directory traversal')) {
      tags.push('path-traversal');
    }

    return tags.slice(0, 5); // Limit to 5 tags
  }

  private async fetchAllCVEsWithPagination(): Promise<CVE[]> {
    const allCVEs: CVE[] = [];
    const kevCVEs = await this.fetchCISAKEV();
    let startIndex = 0;
    const resultsPerPage = 2000;
    let totalResults = 0;
    let currentBatch = 0;

    console.log('Starting comprehensive CVE fetch from NVD and saving to PostgreSQL database...');

    // Import storage here to avoid circular dependencies
    const { storage } = await import('../storage.js');

    do {
      try {
        // Add delay between requests to respect rate limits
        if (currentBatch > 0) {
          console.log(`Fetching batch ${currentBatch + 1}, waiting 3 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 3000)); // Increased delay
        }

        const nvdData = await this.fetchNVDData({
          startIndex: startIndex.toString(),
          resultsPerPage: resultsPerPage.toString()
        });

        totalResults = nvdData.totalResults;
        console.log(`Batch ${currentBatch + 1}: Fetched ${nvdData.vulnerabilities.length} CVEs (${startIndex + 1}-${Math.min(startIndex + resultsPerPage, totalResults)} of ${totalResults})`);

        const batchCVEs = nvdData.vulnerabilities.map(item => 
          this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
        );

        // Save each CVE to database
        for (const cve of batchCVEs) {
          try {
            await storage.createOrUpdateCVE({
              cveId: cve.cveId,
              title: cve.title,
              description: cve.description,
              cvssScore: cve.cvssScore,
              severity: cve.severity,
              vendor: cve.vendor,
              publishedDate: cve.publishedDate,
              updatedDate: cve.updatedDate,
              tags: cve.tags,
              activelyExploited: cve.activelyExploited,
              exploitCount: 0,
              lastExploitCheck: null
            });
          } catch (dbError) {
            console.error(`Error saving CVE ${cve.cveId} to database:`, dbError);
            // Continue with next CVE
          }
        }

        allCVEs.push(...batchCVEs);
        
        // Update cache incrementally as we fetch more data
        const sortedCVEs = [...allCVEs].sort((a, b) => {
          const scoreA = parseFloat(a.cvssScore || '0');
          const scoreB = parseFloat(b.cvssScore || '0');
          if (scoreA !== scoreB) return scoreB - scoreA;
          return new Date(b.publishedDate || '2000-01-01').getTime() - new Date(a.publishedDate || '2000-01-01').getTime();
        });
        
        this.cache.set('all_cves', sortedCVEs);
        this.lastUpdate = Date.now();
        console.log(`Updated cache and saved ${batchCVEs.length} CVEs to database (total: ${allCVEs.length} CVEs)`);
        
        startIndex += resultsPerPage;
        currentBatch++;

        // More aggressive rate limiting and smaller batch limit for production
        if (allCVEs.length >= 50000 || currentBatch >= 25) { // Limit to 50k CVEs for performance
          console.log(`Stopping at ${allCVEs.length} CVEs to maintain performance`);
          break;
        }
      } catch (error) {
        console.error(`Error in batch ${currentBatch + 1}:`, error);
        // Continue with next batch after error
        startIndex += resultsPerPage;
        currentBatch++;
        
        // More lenient error handling - continue if we have some data
        if (currentBatch >= 10 && allCVEs.length === 0) {
          throw error;
        }
        
        // Add longer delay after errors
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    } while (startIndex < totalResults && currentBatch < 25);

    console.log(`Completed CVE fetch and database population: ${allCVEs.length} total CVEs saved to PostgreSQL database`);
    return allCVEs;
  }

  async getCVEsPaginated(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    const cacheKey = `page_${page}_${limit}_${search || 'no_search'}_${severity || 'no_severity'}`;
    
    // Check cache first
    const now = Date.now();
    if (this.cache.has(cacheKey) && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get(cacheKey);
    }

    try {
      // For getting recent CVEs first, we need to fetch from recent years
      // and then sort by date
      const currentYear = new Date().getFullYear();
      
      // Always use reverse pagination to show newest CVEs first
      // For any page, calculate reverse pagination based on total CVE count
      return await this.getReversePaginatedCVEs(params);
      
    } catch (error) {
      console.error('Error fetching paginated CVEs:', error);
      return this.getFallbackPaginatedResult(params);
    }
  }

  private async fetchComprehensiveCVEsInBackground(): Promise<void> {
    // This runs in background to build comprehensive database
    try {
      console.log('Starting background fetch of comprehensive CVE database...');
      
      // Fetch CVEs with pagination - cache updates incrementally inside the function
      await this.fetchAllCVEsWithPagination();
      
      console.log(`Background fetch completed successfully`);
      
    } catch (error) {
      console.error('Error in background CVE fetch:', error);
      // Don't throw error to keep the existing cache
    }
  }

  async searchCVEs(query: string, severity?: string): Promise<CVE[]> {
    // Use direct NVD API search instead of loading all CVEs
    try {
      const searchParams: any = {
        resultsPerPage: '1000',
        startIndex: '0'
      };
      
      if (query?.trim()) {
        searchParams.keywordSearch = query.trim();
      }
      
      if (severity && severity !== 'All Severities') {
        switch (severity.toUpperCase()) {
          case 'CRITICAL':
            searchParams.cvssV3Severity = 'CRITICAL';
            break;
          case 'HIGH':
            searchParams.cvssV3Severity = 'HIGH';
            break;
          case 'MEDIUM':
            searchParams.cvssV3Severity = 'MEDIUM';
            break;
          case 'LOW':
            searchParams.cvssV3Severity = 'LOW';
            break;
        }
      }
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData(searchParams),
        this.fetchCISAKEV()
      ]);
      
      const cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );
      
      return cves.slice(0, 1000); // Limit for performance
      
    } catch (error) {
      console.error('Search error, falling back to basic filter:', error);
      return [];
    }
  }

  async getCVE(id: string): Promise<CVE | undefined> {
    try {
      const nvdData = await this.fetchNVDData({ cveId: id });
      
      if (nvdData.vulnerabilities.length === 0) {
        return undefined;
      }

      const kevCVEs = await this.fetchCISAKEV();
      return this.transformNVDToCVE(nvdData.vulnerabilities[0], kevCVEs.has(id));
    } catch (error) {
      console.error(`Error fetching CVE ${id}:`, error);
      return undefined;
    }
  }

  private getFallbackPaginatedResult(params: CVEQueryParams): PaginatedCVEResult {
    const fallbackCVEs: CVE[] = [
      {
        id: 1,
        cveId: "CVE-2024-1337",
        title: "Critical Remote Code Execution Vulnerability",
        description: "A critical remote code execution vulnerability has been discovered in a widely-used web application framework.",
        cvssScore: "9.8",
        severity: "CRITICAL",
        vendor: "Example Corp",
        publishedDate: "2024-01-15",
        updatedDate: "2024-01-20",
        tags: ["critical", "rce", "actively-exploited"],
        activelyExploited: true,
        exploitCount: 0,
        lastExploitCheck: null
      },
      {
        id: 2,
        cveId: "CVE-2024-2468",
        title: "High Severity SQL Injection Vulnerability",
        description: "A SQL injection vulnerability affects multiple database configurations.",
        cvssScore: "8.1",
        severity: "HIGH",
        vendor: "Database Corp",
        publishedDate: "2024-01-10",
        updatedDate: "2024-01-15",
        tags: ["high", "sqli", "database"],
        activelyExploited: false,
        exploitCount: 0,
        lastExploitCheck: null
      }
    ];
    
    return {
      data: fallbackCVEs.slice(0, params.limit),
      total: fallbackCVEs.length,
      page: params.page,
      limit: params.limit,
      totalPages: Math.ceil(fallbackCVEs.length / params.limit),
      hasNext: false,
      hasPrev: false
    };
  }

  private async getReversePaginatedCVEs(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    
    try {
      // If search is provided, use direct search instead of reverse pagination
      if (search) {
        console.log(`Direct search mode for query: "${search}"`);
        return await this.performDirectSearch(params);
      }
      
      // First, get the total count to calculate reverse pagination
      const totalCountResponse = await this.fetchNVDData({
        resultsPerPage: '1',
        startIndex: '0'
      });
      
      const totalResults = totalCountResponse.totalResults;
      console.log(`Total CVEs in database: ${totalResults}`);
      
      // Calculate reverse pagination for all pages
      const totalPages = Math.ceil(totalResults / limit);
      
      // For faster loading, reduce batch size and optimize pagination
      const batchSize = Math.min(500, limit * 2); // Smaller batch for speed
      const cvesFromEnd = (page - 1) * limit;
      const startFromEnd = Math.max(0, totalResults - batchSize - cvesFromEnd);
      
      console.log(`Fast fetch CVEs for page ${page}/${totalPages} starting from index ${startFromEnd} (${batchSize} CVEs)`);
      
      // Build NVD API parameters with filters
      // Prioritize recent CVEs first - start with last 2 years
      const currentYear = new Date().getFullYear();
      const nvdParams: Record<string, string> = {
        startIndex: startFromEnd.toString(),
        resultsPerPage: batchSize.toString(),
        pubStartDate: `${currentYear - 2}-01-01T00:00:00.000`,
        pubEndDate: new Date().toISOString().split('.')[0] + '.000'
      };
      
      // Add severity filter if provided
      if (severity && severity !== 'All Severities') {
        switch (severity.toUpperCase()) {
          case 'CRITICAL':
            nvdParams.cvssV3Severity = 'CRITICAL';
            break;
          case 'HIGH':
            nvdParams.cvssV3Severity = 'HIGH';
            break;
          case 'MEDIUM':
            nvdParams.cvssV3Severity = 'MEDIUM';
            break;
          case 'LOW':
            nvdParams.cvssV3Severity = 'LOW';
            break;
        }
      }
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData(nvdParams),
        this.fetchCISAKEV()
      ]);
      
      // Transform and sort by date (newest first)
      let cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );
      
      // Additional client-side filtering if needed
      if (search && !nvdParams.keywordSearch) {
        const searchLower = search.toLowerCase();
        cves = cves.filter(cve => 
          cve.cveId.toLowerCase().includes(searchLower) ||
          cve.title.toLowerCase().includes(searchLower) ||
          cve.description.toLowerCase().includes(searchLower) ||
          (cve.vendor && cve.vendor.toLowerCase().includes(searchLower)) ||
          (cve.tags || []).some(tag => tag.toLowerCase().includes(searchLower))
        );
      }
      
      // Apply exact severity filter if needed
      if (severity && severity !== 'All Severities' && !nvdParams.cvssV3Severity) {
        cves = cves.filter(cve => cve.severity.toUpperCase() === severity.toUpperCase());
      }
      
      // Sort by publication date (newest first)
      cves.sort((a, b) => {
        const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
        const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
        if (dateA !== dateB) return dateB - dateA; // Newest first
        
        // If dates are equal, sort by CVSS score as secondary criteria
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });
      
      // Paginate the sorted results properly for the current page
      const startIdx = 0; // We already calculated offset in API call
      const endIdx = Math.min(limit, cves.length);
      const paginatedCVEs = cves.slice(startIdx, endIdx);
      
      const result: PaginatedCVEResult = {
        data: paginatedCVEs,
        total: totalResults,
        page,
        limit,
        totalPages: Math.ceil(totalResults / limit),
        hasNext: page < Math.ceil(totalResults / limit),
        hasPrev: page > 1
      };
      
      // Cache the result
      const cacheKey = `page_${page}_${limit}_${search || 'no_search'}_${severity || 'no_severity'}`;
      this.cache.set(cacheKey, result);
      this.lastUpdate = Date.now();
      
      return result;
      
    } catch (error) {
      console.error('Error fetching recent CVEs from end:', error);
      return await this.getFallbackPaginatedMethod(params);
    }
  }
  
  private async performDirectSearch(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    
    try {
      // For search, use direct NVD API search without reverse pagination
      const searchParams: Record<string, string> = {
        startIndex: ((page - 1) * limit).toString(),
        resultsPerPage: limit.toString(),
        keywordSearch: search!
      };
      
      // Add severity filter if provided
      if (severity && severity !== 'All Severities') {
        switch (severity.toUpperCase()) {
          case 'CRITICAL':
            searchParams.cvssV3Severity = 'CRITICAL';
            break;
          case 'HIGH':
            searchParams.cvssV3Severity = 'HIGH';
            break;
          case 'MEDIUM':
            searchParams.cvssV3Severity = 'MEDIUM';
            break;
          case 'LOW':
            searchParams.cvssV3Severity = 'LOW';
            break;
        }
      }
      
      console.log(`Direct search API call with params:`, searchParams);
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData(searchParams),
        this.fetchCISAKEV()
      ]);
      
      // Transform and sort by date (newest first)
      let cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );
      
      // Sort by publication date (newest first)
      cves.sort((a, b) => {
        const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
        const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
        if (dateA !== dateB) return dateB - dateA; // Newest first
        
        // If dates are equal, sort by CVSS score as secondary criteria
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });
      
      const result: PaginatedCVEResult = {
        data: cves,
        total: nvdData.totalResults,
        page,
        limit,
        totalPages: Math.ceil(nvdData.totalResults / limit),
        hasNext: page < Math.ceil(nvdData.totalResults / limit),
        hasPrev: page > 1
      };
      
      console.log(`Direct search result: ${cves.length} CVEs found for "${search}"`);
      return result;
      
    } catch (error) {
      console.error('Error in direct search:', error);
      return this.getFallbackPaginatedResult(params);
    }
  }
  
  private async getFallbackPaginatedMethod(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    
    // Calculate NVD API pagination
    const startIndex = (page - 1) * limit;
    
    // Build NVD API parameters  
    const nvdParams: Record<string, string> = {
      startIndex: startIndex.toString(),
      resultsPerPage: Math.min(limit * 2, 2000).toString()
    };
    
    // Add search and severity filters
    if (search) {
      nvdParams.keywordSearch = search;
    }
    
    if (severity && severity !== 'All Severities') {
      switch (severity.toUpperCase()) {
        case 'CRITICAL':
          nvdParams.cvssV3Severity = 'CRITICAL';
          break;
        case 'HIGH':
          nvdParams.cvssV3Severity = 'HIGH';
          break;
        case 'MEDIUM':
          nvdParams.cvssV3Severity = 'MEDIUM';
          break;
        case 'LOW':
          nvdParams.cvssV3Severity = 'LOW';
          break;
      }
    }
    
    const [nvdData, kevCVEs] = await Promise.all([
      this.fetchNVDData(nvdParams),
      this.fetchCISAKEV()
    ]);

    let cves = nvdData.vulnerabilities.map(item => 
      this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
    );
    
    // Sort by publication date (newest first)
    cves.sort((a, b) => {
      const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
      const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
      if (dateA !== dateB) return dateB - dateA;
      
      const scoreA = parseFloat(a.cvssScore || '0');
      const scoreB = parseFloat(b.cvssScore || '0');
      return scoreB - scoreA;
    });
    
    const paginatedCVEs = cves.slice(0, limit);
    
    const result: PaginatedCVEResult = {
      data: paginatedCVEs,
      total: nvdData.totalResults,
      page,
      limit,
      totalPages: Math.ceil(nvdData.totalResults / limit),
      hasNext: page < Math.ceil(nvdData.totalResults / limit),
      hasPrev: page > 1
    };
    
    return result;
  }
}