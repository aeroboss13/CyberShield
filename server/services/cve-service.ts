import type { CVE } from "@shared/schema";
import type { IStorage } from '../storage';

interface NVDCVEItem {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        cvssData: {
          baseScore: number;
          baseSeverity: string;
        };
      }>;
    };
    configurations?: Array<{
      nodes: Array<{
        cpeMatch: Array<{
          criteria: string;
          vulnerable: boolean;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
    }>;
  };
}

interface NVDResponse {
  vulnerabilities: NVDCVEItem[];
  totalResults: number;
  resultsPerPage: number;
  startIndex: number;
}

interface CISAKEVItem {
  cveID: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

interface PaginatedCVEResult {
  data: CVE[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

interface CVEQueryParams {
  search?: string;
  severity?: string;
  page: number;
  limit: number;
}

export class CVEService {
  private static instance: CVEService;
  private cache: Map<string, any> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 2 * 60 * 60 * 1000; // 2 hours for individual pages
  private readonly NVD_BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
  private readonly CISA_KEV_URL = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';
  private storage: IStorage;

  constructor(storage: IStorage) {
    this.storage = storage;
  }

  static getInstance(storage?: IStorage): CVEService {
    if (!CVEService.instance && storage) {
      CVEService.instance = new CVEService(storage);
    }
    return CVEService.instance;
  }

  private async getTotalCVECount(): Promise<number> {
    try {
      // First try to get count from cache
      const cacheKey = 'total_cve_count';
      if (this.cache.has(cacheKey) && Date.now() - this.lastUpdate < this.CACHE_DURATION) {
        return this.cache.get(cacheKey);
      }
      
      // Fetch minimal data to get total count
      const nvdData = await this.fetchNVDData({
        startIndex: '0',
        resultsPerPage: '1'
      });
      
      const totalCount = nvdData.totalResults;
      this.cache.set(cacheKey, totalCount);
      
      return totalCount;
    } catch (error) {
      console.error('Error fetching total CVE count:', error);
      return 309139; // Fallback to approximate current count
    }
  }

  private async fetchWithRetry(url: string, options?: RequestInit, retries = 3): Promise<Response> {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            'User-Agent': 'SecHub/1.0',
            ...options?.headers,
          },
        });
        
        if (response.status === 429) {
          // Rate limited, wait and retry
          const waitTime = Math.pow(2, i) * 1000; // Exponential backoff
          console.log(`Rate limited, waiting ${waitTime}ms before retry ${i + 1}/${retries}`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        return response;
      } catch (error) {
        console.error(`Attempt ${i + 1} failed:`, error);
        if (i === retries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
    throw new Error('All retry attempts failed');
  }

  private async fetchCISAKEV(): Promise<Set<string>> {
    try {
      const response = await this.fetchWithRetry(this.CISA_KEV_URL);
      if (!response.ok) {
        console.warn('Failed to fetch CISA KEV data');
        return new Set();
      }

      const data = await response.json();
      const kevCVEs = new Set<string>();
      
      if (data.vulnerabilities && Array.isArray(data.vulnerabilities)) {
        data.vulnerabilities.forEach((item: CISAKEVItem) => {
          if (item.cveID) {
            kevCVEs.add(item.cveID);
          }
        });
      }

      console.log(`Loaded ${kevCVEs.size} CVEs from CISA KEV`);
      return kevCVEs;
    } catch (error) {
      console.error('Error fetching CISA KEV data:', error);
      return new Set();
    }
  }

  private async fetchNVDData(params: Record<string, string> = {}): Promise<NVDResponse> {
    const url = new URL(this.NVD_BASE_URL);
    
    // Default parameters - increased for efficiency
    const defaultParams = {
      resultsPerPage: '2000', // Maximum allowed by NVD API
      startIndex: '0',
      ...params
    };

    Object.entries(defaultParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });

    console.log('Fetching CVE data from NVD:', url.toString());
    
    const response = await this.fetchWithRetry(url.toString());
    
    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
    }

    const data: NVDResponse = await response.json();
    console.log(`Fetched ${data.vulnerabilities.length} CVEs from NVD`);
    
    return data;
  }

  private transformNVDToCVE(nvdItem: NVDCVEItem, isActivelyExploited: boolean): CVE {
    const cve = nvdItem.cve;
    const description = cve.descriptions.find(d => d.lang === 'en')?.value || '';
    const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseScore?.toString() || null;
    const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN';
    
    // Extract vendor/product from CPE if available
    let vendor = null;
    if (cve.configurations?.[0]?.nodes?.[0]?.cpeMatch?.[0]?.criteria) {
      const cpe = cve.configurations[0].nodes[0].cpeMatch[0].criteria;
      const cpeParts = cpe.split(':');
      if (cpeParts.length > 3) {
        vendor = cpeParts[3];
      }
    }

    // Generate tags based on content
    const tags = this.generateTags(description, severity, isActivelyExploited);

    return {
      id: Math.abs(this.hashString(cve.id)), // Generate numeric ID from string
      cveId: cve.id,
      title: `${cve.id} - ${severity} Vulnerability`,
      description: description.length > 500 ? description.substring(0, 500) + '...' : description,
      cvssScore,
      severity: severity.toUpperCase(),
      vendor,
      publishedDate: cve.published.split('T')[0],
      updatedDate: cve.lastModified.split('T')[0],
      tags,
      activelyExploited: isActivelyExploited,
      edbId: null, // ExploitDB ID - not available from NVD API
      references: cve.references ? JSON.stringify(cve.references) : null // Store NVD references as JSON
    };
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash;
  }

  private generateTags(description: string, severity: string, isActivelyExploited: boolean): string[] {
    const tags: string[] = [];
    const lowerDesc = description.toLowerCase();

    // Add severity tag
    tags.push(severity.toLowerCase());

    // Add exploitation status
    if (isActivelyExploited) {
      tags.push('actively-exploited');
    }

    // Add vulnerability type tags
    if (lowerDesc.includes('remote code execution') || lowerDesc.includes('rce')) {
      tags.push('rce');
    }
    if (lowerDesc.includes('sql injection') || lowerDesc.includes('sqli')) {
      tags.push('sqli');
    }
    if (lowerDesc.includes('cross-site scripting') || lowerDesc.includes('xss')) {
      tags.push('xss');
    }
    if (lowerDesc.includes('privilege escalation')) {
      tags.push('privilege-escalation');
    }
    if (lowerDesc.includes('denial of service') || lowerDesc.includes('dos')) {
      tags.push('dos');
    }
    if (lowerDesc.includes('buffer overflow')) {
      tags.push('buffer-overflow');
    }
    if (lowerDesc.includes('path traversal') || lowerDesc.includes('directory traversal')) {
      tags.push('path-traversal');
    }

    return tags.slice(0, 5); // Limit to 5 tags
  }

  private async fetchAllCVEsWithPagination(): Promise<CVE[]> {
    const allCVEs: CVE[] = [];
    const kevCVEs = await this.fetchCISAKEV();
    let startIndex = 0;
    const resultsPerPage = 2000;
    let totalResults = 0;
    let currentBatch = 0;

    console.log('Starting comprehensive CVE fetch from NVD...');

    do {
      try {
        // Add delay between requests to respect rate limits
        if (currentBatch > 0) {
          console.log(`Fetching batch ${currentBatch + 1}, waiting 3 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 3000)); // Increased delay
        }

        const nvdData = await this.fetchNVDData({
          startIndex: startIndex.toString(),
          resultsPerPage: resultsPerPage.toString()
        });

        totalResults = nvdData.totalResults;
        console.log(`Batch ${currentBatch + 1}: Fetched ${nvdData.vulnerabilities.length} CVEs (${startIndex + 1}-${Math.min(startIndex + resultsPerPage, totalResults)} of ${totalResults})`);

        const batchCVEs = nvdData.vulnerabilities.map(item => 
          this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
        );

        allCVEs.push(...batchCVEs);
        
        // Update cache incrementally as we fetch more data
        const sortedCVEs = [...allCVEs].sort((a, b) => {
          const scoreA = parseFloat(a.cvssScore || '0');
          const scoreB = parseFloat(b.cvssScore || '0');
          if (scoreA !== scoreB) return scoreB - scoreA;
          return new Date(b.publishedDate || '2000-01-01').getTime() - new Date(a.publishedDate || '2000-01-01').getTime();
        });
        
        this.cache.set('all_cves', sortedCVEs);
        this.lastUpdate = Date.now();
        console.log(`Updated cache with ${allCVEs.length} CVEs (incremental update)`);
        
        startIndex += resultsPerPage;
        currentBatch++;

        // More aggressive rate limiting and smaller batch limit for production
        if (allCVEs.length >= 50000 || currentBatch >= 25) { // Limit to 50k CVEs for performance
          console.log(`Stopping at ${allCVEs.length} CVEs to maintain performance`);
          break;
        }
      } catch (error) {
        console.error(`Error in batch ${currentBatch + 1}:`, error);
        // Continue with next batch after error
        startIndex += resultsPerPage;
        currentBatch++;
        
        // More lenient error handling - continue if we have some data
        if (currentBatch >= 10 && allCVEs.length === 0) {
          throw error;
        }
        
        // Add longer delay after errors
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    } while (startIndex < totalResults && currentBatch < 25);

    console.log(`Completed CVE fetch: ${allCVEs.length} total CVEs`);
    return allCVEs;
  }

  async getCVEsPaginated(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    const cacheKey = `page_${page}_${limit}_${search || 'no_search'}_${severity || 'no_severity'}`;
    
    // Check cache first
    const now = Date.now();
    if (this.cache.has(cacheKey) && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get(cacheKey);
    }

    try {
      // Priority 1: Search local database first (if search query is provided)
      // EXCEPT for year searches - always use NVD API for comprehensive year results
      const isYearSearch = search && search.match(/^(20\d{2})$/);
      
      if (search && search.trim() && !isYearSearch) {
        console.log(`Searching local CVE database for: "${search}"`);
        const localResult = await this.storage.searchCVEsPaginated({
          search: search.trim(),
          severity: severity === 'All Severities' ? undefined : severity,
          page,
          limit
        });
        
        if (localResult.total > 0) {
          console.log(`Local CVE hit: ${localResult.total} results found`);
          const result: PaginatedCVEResult = {
            data: localResult.cves.map(cve => ({
              id: cve.id,
              cveId: cve.cveId,
              title: cve.title,
              description: cve.description,
              cvssScore: cve.cvssScore,
              severity: cve.severity,
              vendor: cve.vendor,
              publishedDate: cve.publishedDate,
              updatedDate: cve.updatedDate,
              tags: cve.tags || [],
              activelyExploited: cve.activelyExploited || false,
              edbId: cve.edbId,
              references: cve.references
            })),
            total: localResult.total,
            page: localResult.page,
            limit: localResult.limit,
            totalPages: localResult.totalPages,
            hasNext: localResult.page < localResult.totalPages,
            hasPrev: localResult.page > 1
          };
          
          // Cache the local result
          this.cache.set(cacheKey, result);
          this.lastUpdate = now;
          
          return result;
        } else {
          console.log(`No local CVE hit, querying NVD API for: "${search}"`);
        }
      }
      
      if (isYearSearch) {
        console.log(`Year search detected (${search}) - forcing NVD API query for comprehensive results`);
      }
      // For getting recent CVEs first, we need to fetch from recent years
      // and then sort by date
      const currentYear = new Date().getFullYear();
      
      // For the first page without filters, start from the end of the CVE database
      // to get the most recent ones first
      if (page === 1 && !search && (!severity || severity === 'All Severities')) {
        return await this.getRecentCVEsFromEnd(params);
      }
      
      // For filtered searches (year, keyword, severity), use standard pagination
      // For unfiltered searches, use reverse pagination to show newest CVEs first
      const hasFilters = search || (severity && severity !== 'All Severities');
      let startIndex: number;
      let resultsPerPage: number;
      
      if (hasFilters) {
        // Standard pagination for filtered searches
        startIndex = (page - 1) * limit;
        resultsPerPage = limit;
        console.log(`Using standard pagination for filtered search: startIndex=${startIndex}, page=${page}`);
      } else {
        // Reverse pagination for unfiltered searches to show newest CVEs first
        const totalCount = await this.getTotalCVECount();
        startIndex = Math.max(0, totalCount - (page * limit));
        resultsPerPage = Math.min(limit * 2, 2000);
        console.log(`Using reverse pagination for unfiltered search: startIndex=${startIndex}, totalCount=${totalCount}`);
      }
      
      // Build NVD API parameters  
      const nvdParams: Record<string, string> = {
        startIndex: startIndex.toString(),
        resultsPerPage: resultsPerPage.toString()
      };
      
      // Add search parameters if provided
      if (search) {
        // Check if search is a year (e.g., "2024", "2023", "2022")
        const yearMatch = search.match(/^(20\d{2})$/);
        if (yearMatch) {
          const year = yearMatch[1];
          // For now, use keyword search for year - simpler and more reliable
          // This bypasses the 120-day limit issue while still going to NVD API
          nvdParams.keywordSearch = year;
          console.log(`Searching CVEs for year ${year} using keyword search (bypassing local DB)`);
        } else {
          // NVD API supports keyword search for non-year searches
          nvdParams.keywordSearch = search;
        }
      }
      
      // Add severity filter if provided (NVD API uses CVSS scores)
      if (severity && severity !== 'All Severities') {
        switch (severity.toUpperCase()) {
          case 'CRITICAL':
            nvdParams.cvssV3Severity = 'CRITICAL';
            break;
          case 'HIGH':
            nvdParams.cvssV3Severity = 'HIGH';
            break;
          case 'MEDIUM':
            nvdParams.cvssV3Severity = 'MEDIUM';
            break;
          case 'LOW':
            nvdParams.cvssV3Severity = 'LOW';
            break;
        }
      }
      
      console.log(`Fetching CVEs from NVD API with params:`, nvdParams);
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData(nvdParams),
        this.fetchCISAKEV()
      ]);

      // Transform NVD data to our CVE format
      let cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );
      
      // Additional client-side filtering if needed
      // Only apply client-side filtering for non-year searches that weren't handled by NVD API
      // Use the isYearSearch variable already defined above
      if (search && !nvdParams.keywordSearch && !isYearSearch) {
        const searchLower = search.toLowerCase();
        cves = cves.filter(cve => 
          cve.cveId.toLowerCase().includes(searchLower) ||
          cve.title.toLowerCase().includes(searchLower) ||
          cve.description.toLowerCase().includes(searchLower) ||
          (cve.vendor && cve.vendor.toLowerCase().includes(searchLower)) ||
          (cve.tags || []).some(tag => tag.toLowerCase().includes(searchLower))
        );
      }
      
      // Apply exact severity filter if needed
      if (severity && severity !== 'All Severities' && !nvdParams.cvssV3Severity) {
        cves = cves.filter(cve => cve.severity.toUpperCase() === severity.toUpperCase());
      }
      
      // Sort by publication date (newest first), then by CVSS score
      cves.sort((a, b) => {
        const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
        const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
        if (dateA !== dateB) return dateB - dateA; // Newest first
        
        // If dates are equal, sort by CVSS score as secondary criteria
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });
      
      // Paginate results
      const total = nvdData.totalResults;
      const totalPages = Math.ceil(total / limit);
      const paginatedCVEs = cves.slice(0, limit); // Take only what we need for this page
      
      const result: PaginatedCVEResult = {
        data: paginatedCVEs,
        total,
        page,
        limit,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1
      };
      
      // Cache the result
      this.cache.set(cacheKey, result);
      this.lastUpdate = now;
      
      return result;
      
    } catch (error) {
      console.error('Error fetching paginated CVEs:', error);
      return this.getFallbackPaginatedResult(params);
    }
  }

  private async fetchComprehensiveCVEsInBackground(): Promise<void> {
    // This runs in background to build comprehensive database
    try {
      console.log('Starting background fetch of comprehensive CVE database...');
      
      // Fetch CVEs with pagination - cache updates incrementally inside the function
      await this.fetchAllCVEsWithPagination();
      
      console.log(`Background fetch completed successfully`);
      
    } catch (error) {
      console.error('Error in background CVE fetch:', error);
      // Don't throw error to keep the existing cache
    }
  }

  async getAllCVEs(): Promise<CVE[]> {
    // Check cache first
    if (this.cache.has('all_cves') && Date.now() - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get('all_cves');
    }

    // Start background fetch if cache is empty or expired
    this.fetchComprehensiveCVEsInBackground();

    // Return cached data if available, otherwise return empty array
    return this.cache.get('all_cves') || [];
  }

  async searchCVEs(query: string, severity?: string): Promise<CVE[]> {
    const allCVEs = await this.getAllCVEs();
    
    let filteredCVEs = allCVEs.filter((cve: CVE) => {
      // Query matching - skip if query is empty or whitespace
      const normalizedQuery = query?.trim().toLowerCase();
      const matchesQuery = !normalizedQuery || 
        cve.cveId.toLowerCase().includes(normalizedQuery) ||
        cve.title.toLowerCase().includes(normalizedQuery) ||
        cve.description.toLowerCase().includes(normalizedQuery) ||
        (cve.vendor && cve.vendor.toLowerCase().includes(normalizedQuery)) ||
        (cve.tags || []).some((tag: string) => tag.toLowerCase().includes(normalizedQuery));
      
      // Severity matching - improved logic
      const normalizedSeverity = severity?.trim().toUpperCase();
      const matchesSeverity = !normalizedSeverity || 
        normalizedSeverity === "ALL SEVERITIES" || 
        normalizedSeverity === "ALL" ||
        cve.severity.toUpperCase() === normalizedSeverity;
      
      return matchesQuery && matchesSeverity;
    });
    
    // Limit results for performance (show top 1000 most relevant CVEs)
    const limit = 1000;
    if (filteredCVEs.length > limit) {
      console.log(`Limiting CVE results from ${filteredCVEs.length} to ${limit} for performance`);
      filteredCVEs = filteredCVEs.slice(0, limit);
    }
    
    return filteredCVEs;
  }

  async getCVE(id: string): Promise<CVE | undefined> {
    try {
      // First try local storage if the ID looks like a CVE ID
      if (id.match(/^CVE-\d{4}-\d+$/i)) {
        const localCVE = await this.storage.getCVE(id.toUpperCase());
        if (localCVE) {
          console.log(`Found CVE ${id} in local storage`);
          return localCVE;
        }
      }

      // Then try NVD API
      const nvdData = await this.fetchNVDData({ cveId: id });
      
      if (nvdData.vulnerabilities.length === 0) {
        return undefined;
      }

      const kevCVEs = await this.fetchCISAKEV();
      return this.transformNVDToCVE(nvdData.vulnerabilities[0], kevCVEs.has(id));
    } catch (error) {
      console.error(`Error fetching CVE ${id}:`, error);
      
      // Final fallback: try local storage again
      try {
        const localCVE = await this.storage.getCVE(id.toUpperCase());
        if (localCVE) {
          console.log(`Fallback: Found CVE ${id} in local storage after NVD error`);
          return localCVE;
        }
      } catch (localError) {
        console.error(`Local storage fallback also failed for CVE ${id}:`, localError);
      }
      
      return undefined;
    }
  }

  async getCVEById(id: number): Promise<CVE | undefined> {
    try {
      return await this.storage.getCVEById(id);
    } catch (error) {
      console.error(`Error fetching CVE by ID ${id}:`, error);
      return undefined;
    }
  }

  private getFallbackPaginatedResult(params: CVEQueryParams): PaginatedCVEResult {
    const fallbackCVEs: CVE[] = [
      {
        id: 1,
        cveId: "CVE-2024-1337",
        title: "Critical Remote Code Execution Vulnerability",
        description: "A critical remote code execution vulnerability has been discovered in a widely-used web application framework.",
        cvssScore: "9.8",
        severity: "CRITICAL",
        vendor: "Example Corp",
        publishedDate: "2024-01-15",
        updatedDate: "2024-01-20",
        tags: ["critical", "rce", "actively-exploited"],
        activelyExploited: true,
        edbId: null,
        references: null
      },
      {
        id: 2,
        cveId: "CVE-2024-2468",
        title: "High Severity SQL Injection Vulnerability",
        description: "A SQL injection vulnerability affects multiple database configurations.",
        cvssScore: "8.1",
        severity: "HIGH",
        vendor: "Database Corp",
        publishedDate: "2024-01-10",
        updatedDate: "2024-01-15",
        tags: ["high", "sqli", "database"],
        activelyExploited: false,
        edbId: null,
        references: null
      }
    ];
    
    return {
      data: fallbackCVEs.slice(0, params.limit),
      total: fallbackCVEs.length,
      page: params.page,
      limit: params.limit,
      totalPages: Math.ceil(fallbackCVEs.length / params.limit),
      hasNext: false,
      hasPrev: false
    };
  }

  private async getRecentCVEsFromEnd(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { page, limit } = params;
    
    try {
      // First, get the total count to calculate reverse pagination
      const totalCountResponse = await this.fetchNVDData({
        resultsPerPage: '1',
        startIndex: '0'
      });
      
      const totalResults = totalCountResponse.totalResults;
      console.log(`Total CVEs in database: ${totalResults}`);
      
      // Calculate starting point from the end to get the most recent CVEs
      // We want to get a larger batch and then sort by date
      const batchSize = Math.min(limit * 10, 2000); // Get 10x more to have good sorting options
      const startFromEnd = Math.max(0, totalResults - batchSize);
      
      console.log(`Fetching recent CVEs starting from index ${startFromEnd} (${batchSize} CVEs)`);
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData({
          startIndex: startFromEnd.toString(),
          resultsPerPage: batchSize.toString()
        }),
        this.fetchCISAKEV()
      ]);
      
      // Transform and sort by date (newest first)
      let cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );
      
      // Sort by publication date (newest first)
      cves.sort((a, b) => {
        const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
        const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
        if (dateA !== dateB) return dateB - dateA; // Newest first
        
        // If dates are equal, sort by CVSS score as secondary criteria
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });
      
      // Take only what we need for this page
      const paginatedCVEs = cves.slice(0, limit);
      
      const result: PaginatedCVEResult = {
        data: paginatedCVEs,
        total: totalResults,
        page,
        limit,
        totalPages: Math.ceil(totalResults / limit),
        hasNext: page < Math.ceil(totalResults / limit),
        hasPrev: false // First page never has previous
      };
      
      // Cache the result
      this.cache.set(`recent_cves_from_end_${page}_${limit}`, result);
      this.lastUpdate = Date.now();
      
      return result;
      
    } catch (error) {
      console.error('Error fetching recent CVEs from end:', error);
      return await this.getFallbackPaginatedMethod(params);
    }
  }
  
  private async getFallbackPaginatedMethod(params: CVEQueryParams): Promise<PaginatedCVEResult> {
    const { search, severity, page, limit } = params;
    
    // For filtered searches (year, keyword, severity), use standard pagination
    // For unfiltered searches, use reverse pagination to show newest CVEs first
    const hasFilters = search || (severity && severity !== 'All Severities');
    let startIndex: number;
    let resultsPerPage: number;
    
    if (hasFilters) {
      // Standard pagination for filtered searches
      startIndex = (page - 1) * limit;
      resultsPerPage = limit;
      console.log(`Fallback: Using standard pagination for filtered search: startIndex=${startIndex}, page=${page}`);
    } else {
      // Reverse pagination for unfiltered searches to show newest CVEs first
      const totalCount = await this.getTotalCVECount();
      startIndex = Math.max(0, totalCount - (page * limit));
      resultsPerPage = Math.min(limit * 2, 2000);
      console.log(`Fallback: Using reverse pagination for unfiltered search: startIndex=${startIndex}, totalCount=${totalCount}`);
    }
    
    // Build NVD API parameters  
    const nvdParams: Record<string, string> = {
      startIndex: startIndex.toString(),
      resultsPerPage: resultsPerPage.toString()
    };
    
    // Add search and severity filters
    if (search) {
      // Check if search is a year (e.g., "2024", "2023", "2022")
      const yearMatch = search.match(/^(20\d{2})$/);
      if (yearMatch) {
        const year = yearMatch[1];
        // For now, use keyword search for year - simpler and more reliable
        // This bypasses the 120-day limit issue while still going to NVD API
        nvdParams.keywordSearch = year;
        console.log(`Fallback: Searching CVEs for year ${year} using keyword search (bypassing local DB)`);
      } else {
        // NVD API supports keyword search for non-year searches
        nvdParams.keywordSearch = search;
      }
    }
    
    if (severity && severity !== 'All Severities') {
      switch (severity.toUpperCase()) {
        case 'CRITICAL':
          nvdParams.cvssV3Severity = 'CRITICAL';
          break;
        case 'HIGH':
          nvdParams.cvssV3Severity = 'HIGH';
          break;
        case 'MEDIUM':
          nvdParams.cvssV3Severity = 'MEDIUM';
          break;
        case 'LOW':
          nvdParams.cvssV3Severity = 'LOW';
          break;
      }
    }
    
    const [nvdData, kevCVEs] = await Promise.all([
      this.fetchNVDData(nvdParams),
      this.fetchCISAKEV()
    ]);

    let cves = nvdData.vulnerabilities.map(item => 
      this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
    );
    
    // Sort by publication date (newest first)
    cves.sort((a, b) => {
      const dateA = new Date(a.publishedDate || '2000-01-01').getTime();
      const dateB = new Date(b.publishedDate || '2000-01-01').getTime();
      if (dateA !== dateB) return dateB - dateA;
      
      const scoreA = parseFloat(a.cvssScore || '0');
      const scoreB = parseFloat(b.cvssScore || '0');
      return scoreB - scoreA;
    });
    
    const paginatedCVEs = cves.slice(0, limit);
    
    const result: PaginatedCVEResult = {
      data: paginatedCVEs,
      total: nvdData.totalResults,
      page,
      limit,
      totalPages: Math.ceil(nvdData.totalResults / limit),
      hasNext: page < Math.ceil(nvdData.totalResults / limit),
      hasPrev: page > 1
    };
    
    return result;
  }
}