import type { CVE } from "@shared/schema";

interface NVDCVEItem {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        cvssData: {
          baseScore: number;
          baseSeverity: string;
        };
      }>;
    };
    configurations?: Array<{
      nodes: Array<{
        cpeMatch: Array<{
          criteria: string;
          vulnerable: boolean;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
    }>;
  };
}

interface NVDResponse {
  vulnerabilities: NVDCVEItem[];
  totalResults: number;
  resultsPerPage: number;
  startIndex: number;
}

interface CISAKEVItem {
  cveID: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

export class CVEService {
  private static instance: CVEService;
  private cache: Map<string, any> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 2 * 60 * 60 * 1000; // 2 hours
  private readonly NVD_BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
  private readonly CISA_KEV_URL = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';

  static getInstance(): CVEService {
    if (!CVEService.instance) {
      CVEService.instance = new CVEService();
    }
    return CVEService.instance;
  }

  private async fetchWithRetry(url: string, options?: RequestInit, retries = 3): Promise<Response> {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            'User-Agent': 'SecHub/1.0',
            ...options?.headers,
          },
        });
        
        if (response.status === 429) {
          // Rate limited, wait and retry
          const waitTime = Math.pow(2, i) * 1000; // Exponential backoff
          console.log(`Rate limited, waiting ${waitTime}ms before retry ${i + 1}/${retries}`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        return response;
      } catch (error) {
        console.error(`Attempt ${i + 1} failed:`, error);
        if (i === retries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
    throw new Error('All retry attempts failed');
  }

  private async fetchCISAKEV(): Promise<Set<string>> {
    try {
      const response = await this.fetchWithRetry(this.CISA_KEV_URL);
      if (!response.ok) {
        console.warn('Failed to fetch CISA KEV data');
        return new Set();
      }

      const data = await response.json();
      const kevCVEs = new Set<string>();
      
      if (data.vulnerabilities && Array.isArray(data.vulnerabilities)) {
        data.vulnerabilities.forEach((item: CISAKEVItem) => {
          if (item.cveID) {
            kevCVEs.add(item.cveID);
          }
        });
      }

      console.log(`Loaded ${kevCVEs.size} CVEs from CISA KEV`);
      return kevCVEs;
    } catch (error) {
      console.error('Error fetching CISA KEV data:', error);
      return new Set();
    }
  }

  private async fetchNVDData(params: Record<string, string> = {}): Promise<NVDResponse> {
    const url = new URL(this.NVD_BASE_URL);
    
    // Default parameters for recent CVEs
    const defaultParams = {
      resultsPerPage: '100',
      startIndex: '0',
      ...params
    };

    Object.entries(defaultParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });

    console.log('Fetching CVE data from NVD:', url.toString());
    
    const response = await this.fetchWithRetry(url.toString());
    
    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
    }

    const data: NVDResponse = await response.json();
    console.log(`Fetched ${data.vulnerabilities.length} CVEs from NVD`);
    
    return data;
  }

  private transformNVDToCVE(nvdItem: NVDCVEItem, isActivelyExploited: boolean): CVE {
    const cve = nvdItem.cve;
    const description = cve.descriptions.find(d => d.lang === 'en')?.value || '';
    const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseScore?.toString() || null;
    const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN';
    
    // Extract vendor/product from CPE if available
    let vendor = null;
    if (cve.configurations?.[0]?.nodes?.[0]?.cpeMatch?.[0]?.criteria) {
      const cpe = cve.configurations[0].nodes[0].cpeMatch[0].criteria;
      const cpeParts = cpe.split(':');
      if (cpeParts.length > 3) {
        vendor = cpeParts[3];
      }
    }

    // Generate tags based on content
    const tags = this.generateTags(description, severity, isActivelyExploited);

    return {
      id: Math.abs(this.hashString(cve.id)), // Generate numeric ID from string
      cveId: cve.id,
      title: `${cve.id} - ${severity} Vulnerability`,
      description: description.length > 500 ? description.substring(0, 500) + '...' : description,
      cvssScore,
      severity: severity.toUpperCase(),
      vendor,
      publishedDate: cve.published.split('T')[0],
      updatedDate: cve.lastModified.split('T')[0],
      tags,
      activelyExploited: isActivelyExploited
    };
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash;
  }

  private generateTags(description: string, severity: string, isActivelyExploited: boolean): string[] {
    const tags: string[] = [];
    const lowerDesc = description.toLowerCase();

    // Add severity tag
    tags.push(severity.toLowerCase());

    // Add exploitation status
    if (isActivelyExploited) {
      tags.push('actively-exploited');
    }

    // Add vulnerability type tags
    if (lowerDesc.includes('remote code execution') || lowerDesc.includes('rce')) {
      tags.push('rce');
    }
    if (lowerDesc.includes('sql injection') || lowerDesc.includes('sqli')) {
      tags.push('sqli');
    }
    if (lowerDesc.includes('cross-site scripting') || lowerDesc.includes('xss')) {
      tags.push('xss');
    }
    if (lowerDesc.includes('privilege escalation')) {
      tags.push('privilege-escalation');
    }
    if (lowerDesc.includes('denial of service') || lowerDesc.includes('dos')) {
      tags.push('dos');
    }
    if (lowerDesc.includes('buffer overflow')) {
      tags.push('buffer-overflow');
    }
    if (lowerDesc.includes('path traversal') || lowerDesc.includes('directory traversal')) {
      tags.push('path-traversal');
    }

    return tags.slice(0, 5); // Limit to 5 tags
  }

  async getAllCVEs(): Promise<CVE[]> {
    const now = Date.now();
    if (this.cache.has('all_cves') && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get('all_cves');
    }

    try {
      // Get recent CVEs (last 30 days)
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const [nvdData, kevCVEs] = await Promise.all([
        this.fetchNVDData({
          pubStartDate: thirtyDaysAgo.toISOString().split('T')[0] + 'T00:00:00.000',
          pubEndDate: new Date().toISOString().split('T')[0] + 'T23:59:59.999'
        }),
        this.fetchCISAKEV()
      ]);

      const cves = nvdData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );

      // Sort by CVSS score (highest first)
      cves.sort((a, b) => {
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });

      this.cache.set('all_cves', cves);
      this.lastUpdate = now;

      return cves;
    } catch (error) {
      console.error('Error fetching CVE data:', error);
      return this.getFallbackCVEs();
    }
  }

  async searchCVEs(query: string, severity?: string): Promise<CVE[]> {
    const allCVEs = await this.getAllCVEs();
    
    return allCVEs.filter(cve => {
      const matchesQuery = !query || 
        cve.cveId.toLowerCase().includes(query.toLowerCase()) ||
        cve.title.toLowerCase().includes(query.toLowerCase()) ||
        cve.description.toLowerCase().includes(query.toLowerCase()) ||
        (cve.tags || []).some(tag => tag.toLowerCase().includes(query.toLowerCase()));
      
      const matchesSeverity = !severity || 
        severity === "All Severities" || 
        cve.severity.toLowerCase() === severity.toLowerCase();
      
      return matchesQuery && matchesSeverity;
    });
  }

  async getCVE(id: string): Promise<CVE | undefined> {
    try {
      const nvdData = await this.fetchNVDData({ cveId: id });
      
      if (nvdData.vulnerabilities.length === 0) {
        return undefined;
      }

      const kevCVEs = await this.fetchCISAKEV();
      return this.transformNVDToCVE(nvdData.vulnerabilities[0], kevCVEs.has(id));
    } catch (error) {
      console.error(`Error fetching CVE ${id}:`, error);
      return undefined;
    }
  }

  private getFallbackCVEs(): CVE[] {
    return [
      {
        id: 1,
        cveId: "CVE-2024-1337",
        title: "Critical Remote Code Execution Vulnerability",
        description: "A critical remote code execution vulnerability has been discovered in a widely-used web application framework.",
        cvssScore: "9.8",
        severity: "CRITICAL",
        vendor: "Example Corp",
        publishedDate: "2024-01-15",
        updatedDate: "2024-01-20",
        tags: ["critical", "rce", "actively-exploited"],
        activelyExploited: true
      }
    ];
  }
}