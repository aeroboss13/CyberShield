import type { CVE } from "@shared/schema";

interface NVDCVEItem {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        cvssData: {
          baseScore: number;
          baseSeverity: string;
        };
      }>;
    };
    configurations?: Array<{
      nodes: Array<{
        cpeMatch: Array<{
          criteria: string;
          vulnerable: boolean;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
    }>;
  };
}

interface NVDResponse {
  vulnerabilities: NVDCVEItem[];
  totalResults: number;
  resultsPerPage: number;
  startIndex: number;
}

interface CISAKEVItem {
  cveID: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

export class CVEService {
  private static instance: CVEService;
  private cache: Map<string, any> = new Map();
  private lastUpdate: number = 0;
  private readonly CACHE_DURATION = 6 * 60 * 60 * 1000; // 6 hours
  private readonly UPDATE_CHECK_INTERVAL = 2 * 60 * 60 * 1000; // Check for updates every 2 hours
  private isInitializing: boolean = false;
  private initPromise: Promise<void> | null = null;
  private updateTimer: NodeJS.Timeout | null = null;
  private readonly NVD_BASE_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
  private readonly CISA_KEV_URL = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';

  static getInstance(): CVEService {
    if (!CVEService.instance) {
      CVEService.instance = new CVEService();
      CVEService.instance.startAutomaticUpdates();
    }
    return CVEService.instance;
  }

  private startAutomaticUpdates(): void {
    // Start periodic updates for new CVEs
    this.updateTimer = setInterval(async () => {
      try {
        console.log('Checking for new CVE updates...');
        await this.checkForNewCVEs();
      } catch (error) {
        console.error('Error during automatic CVE update:', error);
      }
    }, this.UPDATE_CHECK_INTERVAL);

    console.log('Automatic CVE updates started (every 2 hours)');
  }

  private async checkForNewCVEs(): Promise<void> {
    try {
      // Get CVEs from last 24 hours
      const oneDayAgo = new Date();
      oneDayAgo.setDate(oneDayAgo.getDate() - 1);
      
      const [newData, kevCVEs] = await Promise.all([
        this.fetchNVDData({
          pubStartDate: oneDayAgo.toISOString().split('T')[0] + 'T00:00:00.000',
          pubEndDate: new Date().toISOString().split('T')[0] + 'T23:59:59.999'
        }),
        this.fetchCISAKEV()
      ]);

      if (newData.vulnerabilities.length > 0) {
        console.log(`Found ${newData.vulnerabilities.length} new CVEs in last 24 hours`);
        
        const newCVEs = newData.vulnerabilities.map(item => 
          this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
        );

        // Update cache with new CVEs
        const existingCVEs = this.cache.get('all_cves') || [];
        const allCVEs = [...newCVEs, ...existingCVEs];
        
        // Remove duplicates by CVE ID
        const uniqueCVEs = allCVEs.filter((cve, index, arr) => 
          arr.findIndex(c => c.cveId === cve.cveId) === index
        );

        // Sort by CVSS score and date
        uniqueCVEs.sort((a, b) => {
          const scoreA = parseFloat(a.cvssScore || '0');
          const scoreB = parseFloat(b.cvssScore || '0');
          if (scoreA !== scoreB) return scoreB - scoreA;
          return new Date(b.publishedDate || '2000-01-01').getTime() - new Date(a.publishedDate || '2000-01-01').getTime();
        });

        this.cache.set('all_cves', uniqueCVEs);
        console.log(`Updated CVE cache with ${newCVEs.length} new entries. Total: ${uniqueCVEs.length}`);
      }
    } catch (error) {
      console.error('Error checking for new CVEs:', error);
    }
  }

  public stopAutomaticUpdates(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      console.log('Automatic CVE updates stopped');
    }
  }

  private async fetchWithRetry(url: string, options?: RequestInit, retries = 3): Promise<Response> {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            'User-Agent': 'SecHub/1.0',
            ...options?.headers,
          },
        });
        
        if (response.status === 429) {
          // Rate limited, wait and retry
          const waitTime = Math.pow(2, i) * 1000; // Exponential backoff
          console.log(`Rate limited, waiting ${waitTime}ms before retry ${i + 1}/${retries}`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
        
        return response;
      } catch (error) {
        console.error(`Attempt ${i + 1} failed:`, error);
        if (i === retries - 1) throw error;
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      }
    }
    throw new Error('All retry attempts failed');
  }

  private async fetchCISAKEV(): Promise<Set<string>> {
    try {
      const response = await this.fetchWithRetry(this.CISA_KEV_URL);
      if (!response.ok) {
        console.warn('Failed to fetch CISA KEV data');
        return new Set();
      }

      const data = await response.json();
      const kevCVEs = new Set<string>();
      
      if (data.vulnerabilities && Array.isArray(data.vulnerabilities)) {
        data.vulnerabilities.forEach((item: CISAKEVItem) => {
          if (item.cveID) {
            kevCVEs.add(item.cveID);
          }
        });
      }

      console.log(`Loaded ${kevCVEs.size} CVEs from CISA KEV`);
      return kevCVEs;
    } catch (error) {
      console.error('Error fetching CISA KEV data:', error);
      return new Set();
    }
  }

  private async fetchNVDData(params: Record<string, string> = {}): Promise<NVDResponse> {
    const url = new URL(this.NVD_BASE_URL);
    
    // Default parameters - increased for efficiency
    const defaultParams = {
      resultsPerPage: '2000', // Maximum allowed by NVD API
      startIndex: '0',
      ...params
    };

    Object.entries(defaultParams).forEach(([key, value]) => {
      url.searchParams.append(key, value);
    });

    console.log('Fetching CVE data from NVD:', url.toString());
    
    const response = await this.fetchWithRetry(url.toString());
    
    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
    }

    const data: NVDResponse = await response.json();
    console.log(`Fetched ${data.vulnerabilities.length} CVEs from NVD`);
    
    return data;
  }

  private transformNVDToCVE(nvdItem: NVDCVEItem, isActivelyExploited: boolean): CVE {
    const cve = nvdItem.cve;
    const description = cve.descriptions.find(d => d.lang === 'en')?.value || '';
    const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseScore?.toString() || null;
    const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData.baseSeverity || 'UNKNOWN';
    
    // Extract vendor/product from CPE if available
    let vendor = null;
    if (cve.configurations?.[0]?.nodes?.[0]?.cpeMatch?.[0]?.criteria) {
      const cpe = cve.configurations[0].nodes[0].cpeMatch[0].criteria;
      const cpeParts = cpe.split(':');
      if (cpeParts.length > 3) {
        vendor = cpeParts[3];
      }
    }

    // Generate tags based on content
    const tags = this.generateTags(description, severity, isActivelyExploited);

    return {
      id: Math.abs(this.hashString(cve.id)), // Generate numeric ID from string
      cveId: cve.id,
      title: `${cve.id} - ${severity} Vulnerability`,
      description: description.length > 500 ? description.substring(0, 500) + '...' : description,
      cvssScore,
      severity: severity.toUpperCase(),
      vendor,
      publishedDate: cve.published.split('T')[0],
      updatedDate: cve.lastModified.split('T')[0],
      tags,
      activelyExploited: isActivelyExploited
    };
  }

  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash;
  }

  private generateTags(description: string, severity: string, isActivelyExploited: boolean): string[] {
    const tags: string[] = [];
    const lowerDesc = description.toLowerCase();

    // Add severity tag
    tags.push(severity.toLowerCase());

    // Add exploitation status
    if (isActivelyExploited) {
      tags.push('actively-exploited');
    }

    // Add vulnerability type tags
    if (lowerDesc.includes('remote code execution') || lowerDesc.includes('rce')) {
      tags.push('rce');
    }
    if (lowerDesc.includes('sql injection') || lowerDesc.includes('sqli')) {
      tags.push('sqli');
    }
    if (lowerDesc.includes('cross-site scripting') || lowerDesc.includes('xss')) {
      tags.push('xss');
    }
    if (lowerDesc.includes('privilege escalation')) {
      tags.push('privilege-escalation');
    }
    if (lowerDesc.includes('denial of service') || lowerDesc.includes('dos')) {
      tags.push('dos');
    }
    if (lowerDesc.includes('buffer overflow')) {
      tags.push('buffer-overflow');
    }
    if (lowerDesc.includes('path traversal') || lowerDesc.includes('directory traversal')) {
      tags.push('path-traversal');
    }

    return tags.slice(0, 5); // Limit to 5 tags
  }

  private async fetchAllCVEsWithPagination(): Promise<CVE[]> {
    const allCVEs: CVE[] = [];
    const kevCVEs = await this.fetchCISAKEV();
    let startIndex = 0;
    const resultsPerPage = 2000;
    let totalResults = 0;
    let currentBatch = 0;

    console.log('Starting comprehensive CVE fetch from NVD...');

    do {
      try {
        // Add delay between requests to respect rate limits
        if (currentBatch > 0) {
          console.log(`Fetching batch ${currentBatch + 1}, waiting 2 seconds...`);
          await new Promise(resolve => setTimeout(resolve, 2000));
        }

        const nvdData = await this.fetchNVDData({
          startIndex: startIndex.toString(),
          resultsPerPage: resultsPerPage.toString()
        });

        totalResults = nvdData.totalResults;
        console.log(`Batch ${currentBatch + 1}: Fetched ${nvdData.vulnerabilities.length} CVEs (${startIndex + 1}-${Math.min(startIndex + resultsPerPage, totalResults)} of ${totalResults})`);

        const batchCVEs = nvdData.vulnerabilities.map(item => 
          this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
        );

        allCVEs.push(...batchCVEs);
        startIndex += resultsPerPage;
        currentBatch++;

        // Break if we've fetched all available CVEs or reached a reasonable limit
        if (allCVEs.length >= totalResults || currentBatch >= 150) { // Limit to ~300k CVEs max
          break;
        }
      } catch (error) {
        console.error(`Error in batch ${currentBatch + 1}:`, error);
        // Continue with next batch after error
        startIndex += resultsPerPage;
        currentBatch++;
        
        // Break if too many consecutive errors
        if (currentBatch >= 5 && allCVEs.length === 0) {
          throw error;
        }
      }
    } while (startIndex < totalResults && currentBatch < 150);

    console.log(`Completed CVE fetch: ${allCVEs.length} total CVEs`);
    return allCVEs;
  }

  async getAllCVEs(): Promise<CVE[]> {
    const now = Date.now();
    
    // Return cached data if available and fresh
    if (this.cache.has('all_cves') && now - this.lastUpdate < this.CACHE_DURATION) {
      return this.cache.get('all_cves');
    }

    // If initialization is in progress, wait for it
    if (this.isInitializing && this.initPromise) {
      await this.initPromise;
      return this.cache.get('all_cves') || [];
    }

    // Start initialization
    this.isInitializing = true;
    this.initPromise = this.initializeFullCVEDatabase();
    
    try {
      await this.initPromise;
      return this.cache.get('all_cves') || [];
    } catch (error) {
      console.error('Error initializing CVE database:', error);
      return this.getFallbackCVEs();
    } finally {
      this.isInitializing = false;
      this.initPromise = null;
    }
  }

  private async initializeFullCVEDatabase(): Promise<void> {
    try {
      console.log('Initializing comprehensive CVE database...');
      
      // Try to get recent CVEs first (last 90 days) for quick startup
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
      
      const [recentData, kevCVEs] = await Promise.all([
        this.fetchNVDData({
          pubStartDate: ninetyDaysAgo.toISOString().split('T')[0] + 'T00:00:00.000',
          pubEndDate: new Date().toISOString().split('T')[0] + 'T23:59:59.999',
          resultsPerPage: '2000'
        }),
        this.fetchCISAKEV()
      ]);

      const recentCVEs = recentData.vulnerabilities.map(item => 
        this.transformNVDToCVE(item, kevCVEs.has(item.cve.id))
      );

      // Cache recent CVEs immediately for quick response
      recentCVEs.sort((a, b) => {
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        return scoreB - scoreA;
      });

      this.cache.set('all_cves', recentCVEs);
      this.lastUpdate = Date.now();
      
      console.log(`Quick start: Loaded ${recentCVEs.length} recent CVEs`);

      // Background fetch of all CVEs for comprehensive database
      this.fetchComprehensiveCVEsInBackground();
      
    } catch (error) {
      console.error('Error in CVE initialization:', error);
      throw error;
    }
  }

  private async fetchComprehensiveCVEsInBackground(): Promise<void> {
    // This runs in background to build comprehensive database
    try {
      console.log('Starting background fetch of comprehensive CVE database...');
      
      // Fetch all CVEs with pagination
      const allCVEs = await this.fetchAllCVEsWithPagination();
      
      // Sort by CVSS score and date
      allCVEs.sort((a, b) => {
        const scoreA = parseFloat(a.cvssScore || '0');
        const scoreB = parseFloat(b.cvssScore || '0');
        if (scoreA !== scoreB) return scoreB - scoreA;
        
        // Secondary sort by date
        return new Date(b.publishedDate || '2000-01-01').getTime() - new Date(a.publishedDate || '2000-01-01').getTime();
      });

      // Update cache with comprehensive dataset
      this.cache.set('all_cves', allCVEs);
      this.lastUpdate = Date.now();
      
      console.log(`Background fetch completed: ${allCVEs.length} total CVEs loaded`);
      
    } catch (error) {
      console.error('Error in background CVE fetch:', error);
    }
  }

  async searchCVEs(query: string, severity?: string): Promise<CVE[]> {
    const allCVEs = await this.getAllCVEs();
    
    let filteredCVEs = allCVEs.filter(cve => {
      // Query matching - skip if query is empty or whitespace
      const normalizedQuery = query?.trim().toLowerCase();
      const matchesQuery = !normalizedQuery || 
        cve.cveId.toLowerCase().includes(normalizedQuery) ||
        cve.title.toLowerCase().includes(normalizedQuery) ||
        cve.description.toLowerCase().includes(normalizedQuery) ||
        (cve.vendor && cve.vendor.toLowerCase().includes(normalizedQuery)) ||
        (cve.tags || []).some(tag => tag.toLowerCase().includes(normalizedQuery));
      
      // Severity matching - improved logic
      const normalizedSeverity = severity?.trim().toUpperCase();
      const matchesSeverity = !normalizedSeverity || 
        normalizedSeverity === "ALL SEVERITIES" || 
        normalizedSeverity === "ALL" ||
        cve.severity.toUpperCase() === normalizedSeverity;
      
      return matchesQuery && matchesSeverity;
    });
    
    // Limit results for performance (show top 1000 most relevant CVEs)
    const limit = 1000;
    if (filteredCVEs.length > limit) {
      console.log(`Limiting CVE results from ${filteredCVEs.length} to ${limit} for performance`);
      filteredCVEs = filteredCVEs.slice(0, limit);
    }
    
    return filteredCVEs;
  }

  async getCVE(id: string): Promise<CVE | undefined> {
    try {
      const nvdData = await this.fetchNVDData({ cveId: id });
      
      if (nvdData.vulnerabilities.length === 0) {
        return undefined;
      }

      const kevCVEs = await this.fetchCISAKEV();
      return this.transformNVDToCVE(nvdData.vulnerabilities[0], kevCVEs.has(id));
    } catch (error) {
      console.error(`Error fetching CVE ${id}:`, error);
      return undefined;
    }
  }

  private getFallbackCVEs(): CVE[] {
    return [
      {
        id: 1,
        cveId: "CVE-2024-1337",
        title: "Critical Remote Code Execution Vulnerability",
        description: "A critical remote code execution vulnerability has been discovered in a widely-used web application framework.",
        cvssScore: "9.8",
        severity: "CRITICAL",
        vendor: "Example Corp",
        publishedDate: "2024-01-15",
        updatedDate: "2024-01-20",
        tags: ["critical", "rce", "actively-exploited"],
        activelyExploited: true
      }
    ];
  }
}